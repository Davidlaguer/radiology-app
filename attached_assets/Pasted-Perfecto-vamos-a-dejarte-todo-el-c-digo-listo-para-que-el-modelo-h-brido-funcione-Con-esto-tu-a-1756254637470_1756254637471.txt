Perfecto üôå, vamos a dejarte todo el c√≥digo listo para que el modelo h√≠brido funcione.
Con esto tu app resolver√° hallazgos en local (con findings.json + fuzzyLexicon.json) y usar√° OpenAI s√≥lo si no logra clasificarlos.

‚ö†Ô∏è Tranquilo, no pongas tu API key directamente en el c√≥digo ‚Äî se usa desde .env o desde Replit Secrets.

üìÇ Archivos modificados / a√±adidos
1. src/utils/openaiClassify.ts ‚úÖ nuevo archivo
// src/utils/openaiClassify.ts
// Clasificador h√≠brido: local primero, OpenAI solo si no se reconoce.
// Requiere VITE_OPENAI_API_KEY y VITE_USE_OPENAI=1 en .env o Replit Secrets.

export type RegionTag = 'TC-TORAX' | 'TC-ABDOMEN';
export type ContrastTag = 'CON CONTRASTE' | 'SIN CONTRASTE';

export type LabeledFinding = {
  input_text: string;
  official_label: string | null;
  class_type: 'patologico' | 'adicional' | 'suelto';
  target_frase_normal: string | null;
  note?: string;
};

// Normalizaci√≥n r√°pida
function normalize(s: string) {
  return s
    .toLowerCase()
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .replace(/[^\p{L}\p{N}\s]/gu, '')
    .replace(/\s+/g, ' ')
    .trim();
}

export async function classifyWithOpenAI(
  item: string,
  regions: RegionTag[],
  contrast: ContrastTag | null,
  findingsTable: any[],
  normalPhrases: any[],
  fuzzyTable: any[],
  opts?: { model?: string }
): Promise<LabeledFinding> {
  const apiKey = import.meta.env.VITE_OPENAI_API_KEY as string | undefined;
  const useOpenAI = import.meta.env.VITE_USE_OPENAI === '1';

  if (!useOpenAI || !apiKey) {
    return {
      input_text: item,
      official_label: null,
      class_type: 'suelto',
      target_frase_normal: null,
      note: 'OpenAI desactivado.',
    };
  }

  const patologicos: string[] = [];
  const adicionales: string[] = [];
  for (const row of findingsTable) {
    patologicos.push(...(row.hallazgos_patologicos || []));
    adicionales.push(...(row.hallazgos_adicionales || []));
  }

  const posiblesFrases = normalPhrases.map((x: any) => x.text);

  const systemPrompt =
    `Eres un asistente que clasifica hallazgos radiol√≥gicos en espa√±ol.\n` +
    `Cat√°logo permitido:\n` +
    `Patol√≥gicos: ${JSON.stringify(patologicos)}\n` +
    `Adicionales: ${JSON.stringify(adicionales)}\n` +
    `Frases normales posibles: ${JSON.stringify(posiblesFrases)}\n` +
    `Responde SOLO con JSON v√°lido.\n` +
    `Esquema: { "input_text": "...", "official_label": string|null, "class_type": "patologico|adicional|suelto", "target_frase_normal": string|null }`;

  const res = await fetch('https://api.openai.com/v1/responses', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: opts?.model || 'gpt-4.1-mini',
      input: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: item },
      ],
      response_format: {
        type: 'json_schema',
        json_schema: {
          name: 'finding_schema',
          schema: {
            type: 'object',
            properties: {
              input_text: { type: 'string' },
              official_label: { type: ['string', 'null'] },
              class_type: { type: 'string', enum: ['patologico', 'adicional', 'suelto'] },
              target_frase_normal: { type: ['string', 'null'] },
            },
            required: ['input_text', 'class_type'],
            additionalProperties: false,
          },
          strict: true,
        },
      },
    }),
  });

  if (!res.ok) {
    return {
      input_text: item,
      official_label: null,
      class_type: 'suelto',
      target_frase_normal: null,
      note: `Error OpenAI: ${res.status}`,
    };
  }

  const data = await res.json();
  const text = (data?.output_text ?? '').trim();

  try {
    return JSON.parse(text);
  } catch {
    return {
      input_text: item,
      official_label: null,
      class_type: 'suelto',
      target_frase_normal: null,
      note: 'Fallo parseo OpenAI',
    };
  }
}

2. src/App.tsx ‚úÖ modificado

He cambiado la parte de handleGenerate() ‚Üí ahora los hallazgos sueltos llaman a OpenAI.

Busca en tu archivo la parte de:

for (const item of rawItems) {
  const n = normalize(item);
  ...


Y sustit√∫yela entera por esto:

import { classifyWithOpenAI } from './utils/openaiClassify';  // ‚¨ÖÔ∏è NUEVO IMPORT

...

for (const item of rawItems) {
  const n = normalize(item);
  if (!n) continue;
  if (n.includes('valida frases normales')) continue;

  let mf: MappedFinding | null = null;

  // 1) exact match en tablas
  const hitPat = findingCatalog.pathological.get(n);
  if (hitPat) {
    mf = { tipo: 'patologico', zona: hitPat.zona, fraseNormal: hitPat.fraseNormal, texto: ensureDot(item) };
  }
  const hitAdd = findingCatalog.additional.get(n);
  if (!mf && hitAdd) {
    mf = { tipo: 'adicional', zona: hitAdd.zona, fraseNormal: hitAdd.fraseNormal, texto: ensureDot(item) };
  }

  // 2) fuzzy en fuzzyLexicon
  if (!mf) {
    const fz = fuzzyIndex.get(n);
    if (fz && !(fz.excluir || []).some(ex => normalize(ex) === n)) {
      const oficialN = normalize(fz.oficial);
      const hitPat2 = findingCatalog.pathological.get(oficialN);
      const hitAdd2 = findingCatalog.additional.get(oficialN);
      if (hitPat2) mf = { tipo: 'patologico', zona: hitPat2.zona, fraseNormal: hitPat2.fraseNormal, texto: ensureDot(fz.oficial) };
      else if (hitAdd2) mf = { tipo: 'adicional', zona: hitAdd2.zona, fraseNormal: hitAdd2.fraseNormal, texto: ensureDot(fz.oficial) };
    }
  }

  // 3) si sigue suelto ‚Üí llama a OpenAI
  if (!mf) {
    const res = await classifyWithOpenAI(item, regions, contrast, findingsJson as any, normalPhrases as any, fuzzyLexicon as any);
    if (res.class_type === 'patologico' && res.target_frase_normal) {
      mf = { tipo: 'patologico', fraseNormal: res.target_frase_normal, texto: ensureDot(res.input_text) };
    } else if (res.class_type === 'adicional' && res.target_frase_normal) {
      mf = { tipo: 'adicional', fraseNormal: res.target_frase_normal, texto: ensureDot(res.input_text) };
    } else {
      mf = { tipo: 'suelto', texto: ensureDot(res.input_text) };
    }
  }

  mapped.push(mf);
}

3. .env ‚úÖ nuevo archivo en la ra√≠z del proyecto

Crea este archivo en la ra√≠z del proyecto:

VITE_USE_OPENAI=1
VITE_OPENAI_API_KEY=sk-proj-xxxxxxxxxxxxxxxx


En Replit ‚Üí pon estas dos variables en Secrets en vez de .env.

üöÄ Flujo ahora

Dictas ‚Üí rawItems se separan en frases.

Cada frase se intenta clasificar en:

Local exacto (findings.json).

Fuzzy (fuzzyLexicon.json).

Si no se reconoce ‚Üí OpenAI (classifyWithOpenAI).

OpenAI devuelve JSON con:

class_type: patologico|adicional|suelto

target_frase_normal si corresponde.

Se integra en tu informe con las 11 normas.