A. src/utils/postprocess.ts completo (corrige y refuerza reglas, mejora regex de adenopatías, litiasis y pleura).

B. Parche mínimo en src/App.tsx (mantener tu texto original cuando se hace fuzzy-match, pero usando el oficial solo para localizar la frase normal a reemplazar/añadir).

A) Reemplaza entero: src/utils/postprocess.ts
// src/utils/postprocess.ts

/**
 * Postproceso de líneas para el informe:
 * - Elimina contradicciones (Norma 3) típicas: nódulo pulmonar, adenopatías (torácicas e intraabdominales), colelitiasis, litiasis renal, derrame pleural…
 * - Modificación parcial de normales (Norma 8) para hígado (“No se observan otras lesiones focales hepáticas.”).
 * - Deduplica el cierre y garantiza uno único al final.
 * - Modo plantilla: reagrupa por secciones anatómicas en orden estable.
 */

export type PostprocessOptions = {
  templateMode?: boolean;     // Activa reorden anatómico (Norma 11)
  literals?: string[];        // (Opcional) Literales de tus frases normales, para afinar clasificador
  closingLiteral?: string;    // Por defecto: "Sin otros hallazgos."
};

// -------------------------------
// Utils
// -------------------------------
const SENTENCE_END = /[.:]$/;
const DEFAULT_CLOSING = "Sin otros hallazgos.";

function ensureDot(s: string): string {
  const t = s.trim();
  if (!t) return t;
  return SENTENCE_END.test(t) ? t : `${t}.`;
}
function normalize(s: string) {
  return s
    .toLowerCase()
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .replace(/[^\p{L}\p{N}\s]/gu, "")
    .replace(/\s+/g, " ")
    .trim();
}
function eq(a: string, b: string) {
  return normalize(a) === normalize(b);
}

// -------------------------------
// Contradicciones (Norma 3)
// Si aparece el hallazgo, se eliminan estas frases normales
// -------------------------------

/**
 * NOTA: nos basamos en el texto final (ya consolidado en `working`).
 */
const CONTRADICTION_RULES: Array<{
  trigger: RegExp;       // hallazgo que activa la regla
  dropNormals: RegExp[]; // normales a suprimir
}> = [
  // Parénquima / Nódulos
  {
    trigger: /\b(n[oó]dulo(s)? pulmonar(es)?|espiculad[oa])\b/i,
    dropNormals: [
      /par[eé]nquima pulmonar sin alteraciones a destacar/i,
      /no se observan condensaciones de espacio a[eé]reo ni n[oó]dulos pulmonares/i,
    ],
  },

  // Adenopatías torácicas (axilares / supraclaviculares / mediastínicas / hiliares)
  {
    // requiere la palabra adenopatía y tipo, más “aumentada” o tamaño en mm
    trigger: /\badenopat[ií]a(s)?.*?\b(axilar(es)?|supraclaviculares?|mediast[ií]nic(a|as)|hiliar(es)?)\b.*?\b(aumentad[ao]s?|de\s*\d+\s*mm)\b/i,
    dropNormals: [
      /no se observan adenopat[ií]as supraclaviculares o axilares aumentadas de tama/i,
      /no se observan adenopat[ií]as mediast[ií]nicas o hiliares aumentadas de tama/i,
    ],
  },

  // Adenopatías intraabdominales/pélvicas/inguinales
  {
    trigger: /\badenopat[ií]a(s)?.*?\b(retroperitoneal(es)?|mesent[eé]ric(a|as)|para[ao][ó]rtic(a|as)|iliac(a|as)|p[eé]lvic(a|as)|inguinal(es)?)\b.*?\b(aumentad[ao]s?|de\s*\d+\s*mm)\b/i,
    dropNormals: [
      /no se observan adenopat[ií]as intraabdominales aumentadas de tama/i,
      /no se observan adenopat[ií]as p[eé]lvicas o inguinales aumentadas de tama/i,
    ],
  },

  // Colelitiasis
  {
    trigger: /\b(colelitiasis|litiasis (vesicular|biliar))\b/i,
    dropNormals: [
      /ves[ií]cula biliar sin evidencia de litiasis en su interior, engrosamientos murales o signos inflamatorios agudos/i,
    ],
  },

  // Riñón / Litiasis (renal, ureteral, pieloureteral…)
  {
    trigger: /\b(litiasis|microlitiasis|c[aá]lculo(s)?)\b.*\b(renal|riñ[oó]n|pielo\w*|ur[eé]ter|ureteral|v[ií]a(s)? urinaria(s)?)\b/i,
    dropNormals: [
      // negativas renales típicas bilaterales/unilaterales
      /no se observan lesiones focales ni dilataci[oó]n de la v[ií]a urinaria (derecha|izquierda)/i,
      /no se observan lesiones focales ni dilataci[oó]n de las v[ií]as urinarias/i,
    ],
  },

  // Derrame pleural
  {
    trigger: /\bderrame\b.*\bpleural(es)?\b|\bderrame pleural\b/i,
    dropNormals: [/espacios pleurales libres/i],
  },

  // Bocio / patología tiroidea → (solo si algún día añades una normal de tiroides)
  // {
  //   trigger: /\bbocio\b|\bpatolog[ií]a tiroidea\b|\bn[oó]dulo tiroideo\b/i,
  //   dropNormals: [/^tiroid(e|es) .* normal/i],
  // },
];

// -------------------------------
// Modificación parcial (Norma 8) — hígado
// -------------------------------
const HEPATIC_BENIGN_TRIGGERS = /\b(hemangioma(s)?|quiste(s)? hep[aá]tico(s)?)\b/i;
const HEPATIC_FOCAL_NEGATIVE = /no se observan lesiones focales hep[aá]ticas/i;
const HEPATIC_FOCAL_NEGATIVE_REPLACEMENT =
  "No se observan otras lesiones focales hepáticas.";

// -------------------------------
// Cierre único
// -------------------------------
function ensureSingleClosing(lines: string[], closing = DEFAULT_CLOSING): string[] {
  const tgt = closing.trim();
  const out: string[] = [];
  let has = false;
  for (const l of lines) {
    if (eq(l, tgt)) {
      if (!has) {
        out.push(tgt);
        has = true;
      }
    } else {
      out.push(l);
    }
  }
  if (!has) out.push(tgt);
  return out;
}

// -------------------------------
// Orden anatómico (template mode)
// -------------------------------
const SECTION_ORDER = [
  "thorax.mediastino",
  "thorax.parenquima",
  "thorax.vascular",
  "thorax.pleura",
  "thorax.pared_cuello_tiroides",

  "abd.hepatobiliar.higado",
  "abd.hepatobiliar.vb_vias",
  "abd.bazo",
  "abd.pancreas",
  "abd.suprarrenales",
  "abd.renal",
  "abd.adenopatias",
  "abd.peritoneo",
  "abd.otro",
] as const;
type SectionKey = (typeof SECTION_ORDER)[number];

function classifyLine(line: string, literals?: string[]): SectionKey {
  const s = normalize(line);

  if (literals && literals.some((lit) => eq(lit, line))) {
    if (/mediastin/i.test(s)) return "thorax.mediastino";
    if (/par[eé]nquima|n[oó]dulo(s)? pulmonar/i.test(s)) return "thorax.parenquima";
    if (/arteria pulmonar|tep|aorta/i.test(s)) return "thorax.vascular";
    if (/pleural|pleurodesis|derrame/i.test(s)) return "thorax.pleura";
    if (/tiroid/i.test(s)) return "thorax.pared_cuello_tiroides";
    if (/h[ií]gado|hep[aá]tic/i.test(s)) return "abd.hepatobiliar.higado";
    if (/ves[ií]cula|biliar|col[eé]doco/i.test(s)) return "abd.hepatobiliar.vb_vias";
    if (/bazo|esplen/i.test(s)) return "abd.bazo";
    if (/p[aá]ncreas|wirsung/i.test(s)) return "abd.pancreas";
    if (/suprarrenal|adrenal/i.test(s)) return "abd.suprarrenales";
    if (/riñ[oó]n|renal|v[ií]a urinaria|v[ií]as urinarias|pielo|ur[eé]ter|litiasis/i.test(s))
      return "abd.renal";
    if (/adenopat[ií]a|ganglio/i.test(s)) return "abd.adenopatias";
    if (/colecci[oó]n|ascitis|neumoperitoneo|carcinomatosis|trabecul/i.test(s))
      return "abd.peritoneo";
    return "abd.otro";
  }

  if (/mediastin/i.test(s)) return "thorax.mediastino";
  if (/par[eé]nquima|n[oó]dulo(s)? pulmonar|vidrio|atelect|mosaico|trapping/i.test(s))
    return "thorax.parenquima";
  if (/arteria pulmonar|tep|aorta/i.test(s)) return "thorax.vascular";
  if (/pleural|pleurodesis|derrame/i.test(s)) return "thorax.pleura";
  if (/tiroid|pared tor[aá]cica|clavicular|axilar|supraclav/i.test(s))
    return "thorax.pared_cuello_tiroides";

  if (/h[ií]gado|hep[aá]tic/i.test(s)) return "abd.hepatobiliar.higado";
  if (/ves[ií]cula|biliar|col[eé]doco|colelitiasis/i.test(s)) return "abd.hepatobiliar.vb_vias";
  if (/bazo|esplen/i.test(s)) return "abd.bazo";
  if (/p[aá]ncreas|wirsung|quiste.*pancre[aá]tico/i.test(s)) return "abd.pancreas";
  if (/suprarrenal|adrenal/i.test(s)) return "abd.suprarrenales";
  if (/riñ[oó]n|renal|v[ií]a urinaria|v[ií]as urinarias|pielo|ur[eé]ter|litiasis/i.test(s))
    return "abd.renal";
  if (/adenopat[ií]a|ganglio/i.test(s)) return "abd.adenopatias";
  if (/colecci[oó]n|ascitis|neumoperitoneo|carcinomatosis|trabecul/i.test(s))
    return "abd.peritoneo";

  return "abd.otro";
}

function reorderBySections(lines: string[], literals?: string[]): string[] {
  const buckets = new Map<SectionKey, string[]>();
  for (const k of SECTION_ORDER) buckets.set(k, []);
  for (const line of lines) {
    const key = classifyLine(line, literals);
    buckets.get(key)!.push(line);
  }
  const result: string[] = [];
  for (const k of SECTION_ORDER) {
    const arr = buckets.get(k)!;
    if (arr.length) result.push(...arr);
  }
  return result;
}

// -------------------------------
// Núcleo
// -------------------------------
export function applyPostprocessNorms(
  inputLines: string[],
  options: PostprocessOptions = {}
): string[] {
  const closing = options.closingLiteral?.trim() || DEFAULT_CLOSING;

  // 1) limpieza + punto final
  let lines = inputLines
    .map((l) => l.trim())
    .filter(Boolean)
    .map(ensureDot);

  // 2) contradicciones activas segun el conjunto actual
  const joined = lines.join(" ");
  const active = CONTRADICTION_RULES.filter((r) => r.trigger.test(joined));

  if (active.length) {
    lines = lines.filter((line) => {
      for (const rule of active) {
        for (const rx of rule.dropNormals) {
          if (rx.test(line) || rx.test(normalize(line))) return false;
        }
      }
      return true;
    });
  }

  // 3) Norma 8 (hígado): si hay quistes/hemangiomas, matizar la negativa
  if (HEPATIC_BENIGN_TRIGGERS.test(joined)) {
    lines = lines.map((line) =>
      HEPATIC_FOCAL_NEGATIVE.test(line)
        ? ensureDot(HEPATIC_FOCAL_NEGATIVE_REPLACEMENT)
        : line
    );
  }

  // 4) deduplicar + cierre único
  const seen = new Set<string>();
  lines = lines.filter((l) => {
    const key = normalize(l);
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
  lines = lines.filter((l) => !eq(l, closing));
  lines = ensureSingleClosing(lines, closing);

  // 5) ordenar por secciones (template mode)
  if (options.templateMode) {
    lines = reorderBySections(lines, options.literals);
  }

  return lines;
}

B) Parche mínimo en src/App.tsx para conservar TUS palabras

Ahora, cuando hay fuzzy-match, seguiremos usando el hallazgo oficial para localizar la zona/frase normal correcta, pero el texto que se inserta será el original que dictaste (p. ej., “Bocio tiroideo”), no “Patología tiroidea”.

Busca en tu handleGenerate() el bucle donde construyes mapped y sustituye la parte del fuzzy por esta:

// ...dentro de for (const item of rawItems) { ... }
      // 2.b) fuzzy → usa el *oficial* solo para anclar zona/fraseNormal,
      // pero RESPETA el texto original dictado para la salida
      if (!mf) {
        const fz = fuzzyIndex.get(n);
        if (fz && !(fz.excluir || []).some(ex => normalize(ex) === n)) {
          const oficialN = normalize(fz.oficial);
          const hitPat = findingCatalog.pathological.get(oficialN);
          const hitAdd = findingCatalog.additional.get(oficialN);
          if (hitPat) {
            mf = {
              tipo: 'patologico',
              zona: hitPat.zona,
              fraseNormal: hitPat.fraseNormal,
              texto: item,            // ← conserva tus palabras
              oficial: fz.oficial
            };
          } else if (hitAdd) {
            mf = {
              tipo: 'adicional',
              zona: hitAdd.zona,
              fraseNormal: hitAdd.fraseNormal,
              texto: item,            // ← conserva tus palabras
              oficial: fz.oficial
            };
          }
        }
      }


No toques el resto del bucle. Con esto arreglas el caso de “Bocio tiroideo”.