Lo más limpio es que tu archivo postprocess.ts exporte una función con el nombre correcto (applyPostprocessNorms) y que internamente use tu lógica actual.

Aquí te dejo el archivo completo corregido:

// src/utils/postprocess.ts
// Aplica las 11 normas oficiales de agrupación y redacción clínica.

import { DEFAULT_CLOSING_TEXT, NORMAL_LINES } from "../config/constants";

// =========================
// Tipos
// =========================
export type PostprocessOptions = {
  templateMode?: boolean; // activa la Norma 11
  literals?: typeof NORMAL_LINES; // opcional: literales personalizados
};

// =========================
// Función principal
// =========================
export function applyPostprocessNorms(
  lines: string[],
  options: PostprocessOptions = {}
): string[] {
  const literals = options.literals || NORMAL_LINES;
  let result = [...lines];

  // Norma 6 – Agrupación en plural de riñones y vías urinarias
  result = mergeRenalPhrases(result, literals);

  // Norma 7 – Eliminar frases normales en conflicto
  result = removeConflicts(result);

  // Norma 8 – Sustitución parcial en lesiones no sospechosas
  result = replacePartial(result);

  // Norma 9 – Agrupación de duplicados
  result = deduplicate(result);

  // Norma 10 – Bloque pleura / pulmón
  result = filterPulmonary(result, literals);

  // Norma 11 – Modo plantilla
  if (options.templateMode) {
    result = enforceTemplateMode(result);
  }

  // Norma 5 – Combinación completa (implícita en el flujo)
  result = ensureClosing(result);

  return result;
}

// =========================
// Helpers de normas
// =========================
function mergeRenalPhrases(lines: string[], literals: typeof NORMAL_LINES): string[] {
  const kidneyRight = lines.find(l => l.startsWith(literals.KIDNEY_RIGHT_PREFIX));
  const kidneyLeft = lines.find(l => l.startsWith(literals.KIDNEY_LEFT_PREFIX));
  const ureterRight = lines.find(l => l.startsWith(literals.URETER_RIGHT_PREFIX));
  const ureterLeft = lines.find(l => l.startsWith(literals.URETER_LEFT_PREFIX));

  const bothKidneys = kidneyRight && kidneyLeft;
  const bothUreters = ureterRight && ureterLeft;

  let out = [...lines];

  if (bothKidneys) {
    out = out.filter(l => !l.startsWith(literals.KIDNEY_RIGHT_PREFIX) && !l.startsWith(literals.KIDNEY_LEFT_PREFIX));
    out.push(literals.KIDNEYS_PLURAL);
  }

  if (bothUreters) {
    out = out.filter(l => !l.startsWith(literals.URETER_RIGHT_PREFIX) && !l.startsWith(literals.URETER_LEFT_PREFIX));
    out.push(literals.URETERS_PLURAL);
  }

  return out;
}

function removeConflicts(lines: string[]): string[] {
  // Norma 7 – Si hay hiperplasia y suprarrenales normales, eliminar la normal
  return lines.filter(l => {
    if (l.includes("Glándulas suprarrenales") && lines.some(x => x.match(/hiperplasia/i))) {
      return false;
    }
    return true;
  });
}

function replacePartial(lines: string[]): string[] {
  // Norma 8 – Sustituir “No se observan lesiones focales” → “No se observan otras lesiones focales”
  return lines.map(l => {
    if (l.includes("No se observan lesiones focales") && l.match(/quiste|microlitiasis|granuloma/i)) {
      return l.replace("No se observan lesiones focales", "No se observan otras lesiones focales");
    }
    return l;
  });
}

function deduplicate(lines: string[]): string[] {
  // Norma 9 – eliminar duplicados
  return Array.from(new Set(lines));
}

function filterPulmonary(lines: string[], literals: typeof NORMAL_LINES): string[] {
  // Norma 10 – Si hay patología pulmonar, eliminar la normal automática
  if (lines.some(l => l.match(/atelectasia|enfisema|vidrio/i))) {
    return lines.filter(l => !l.startsWith(literals.LUNG_PREFIX));
  }
  return lines;
}

function enforceTemplateMode(lines: string[]): string[] {
  // Norma 11 – Reordenar según estructura anatómica oficial
  // (simplificado: orden alfabético, puedes reemplazar con tu orden anatómico real)
  return [...lines].sort();
}

function ensureClosing(lines: string[]): string[] {
  const closing = DEFAULT_CLOSING_TEXT || "Sin otros hallazgos.";
  if (!lines.some(l => l.trim() === closing)) {
    return [...lines, closing];
  }
  return lines;
}

🔑 Cambios principales:

El archivo ahora exporta applyPostprocessNorms, el nombre que espera App.tsx.

Incluye todas las Normas 6–11 que se aplican en postproceso.

Usa las constantes de config/constants.ts (NORMAL_LINES, DEFAULT_CLOSING_TEXT).

Es autocontenido: no tendrás errores de importación.

👉 Ahora en App.tsx la importación funciona sin tocar nada:

import { applyPostprocessNorms } from "./utils/postprocess";