¡hecho! aquí tienes los dos archivos completos que hay que tocar para respetar EXACTAMENTE tu formato de saltos de línea:

Doble salto solo entre el bloque de pleura y el bloque de hígado.

Título / Técnica / HALLAZGOS con los dobles saltos ya controlados desde App.tsx.

Todo lo demás: salto simple.

src/utils/postprocess.ts (archivo completo)
/* eslint-disable no-control-regex */

/**
 * Postproceso de líneas de HALLAZGOS:
 * - Reagrupa por secciones anatómicas reales
 * - Ordena las secciones en el orden clínico acordado
 * - Mantiene "Sin otros hallazgos." como cierre
 * - Formatea con saltos: doble SOLO entre pleura → hígado; resto simple
 *
 * La entrada típica son líneas sueltas con punto final.
 */

export type SectionKey =
  | 'thorax.mediastino'            // Estructuras mediastínicas...
  | 'thorax.vascular'              // Arteria pulmonar / TEP
  | 'thorax.ganglios'              // Adenopatías mediastínicas/hiliares/supraclav/axilares
  | 'thorax.parenquima'            // Parénquima pulmonar / nódulos / opacidades
  | 'thorax.pleura'                // Pleura

  | 'abd.hepatobiliar.higado'      // Hígado + lesiones focales hepáticas
  | 'abd.hepatobiliar.vasos'       // Vena porta / suprahepáticas / eje esplenoportal
  | 'abd.hepatobiliar.vias_ves'    // Vía biliar + vesícula (colelitiasis, barro, colangitis)

  | 'abd.bazo_pancreas_suprarrenal'
  | 'abd.renal_uro'
  | 'abd.ganglionar'
  | 'abd.peritoneo_mesenterio'

  | 'unknown'                      // Todo lo que no podamos clasificar

export interface PostprocessOptions {
  templateMode?: boolean; // cuando true, reagrupa y ordena todo (Norma 11)
  literalsBySection?: Partial<Record<SectionKey, string[]>>; // opcional: literales exactos -> sección
}

/** Orden clínico final de secciones dentro de HALLAZGOS */
export const SECTION_ORDER: SectionKey[] = [
  // TÓRAX
  'thorax.mediastino',
  'thorax.vascular',
  'thorax.ganglios',
  'thorax.parenquima',
  'thorax.pleura',

  // ABDOMEN
  'abd.hepatobiliar.higado',
  'abd.hepatobiliar.vasos',
  'abd.hepatobiliar.vias_ves',
  'abd.bazo_pancreas_suprarrenal',
  'abd.renal_uro',
  'abd.ganglionar',
  'abd.peritoneo_mesenterio',

  // Por si algo no encaja
  'unknown',
];

/* ------------------------ utilidades básicas ------------------------ */

export function ensureDot(s: string) {
  const t = s.trim();
  if (!t) return t;
  return /[.:]$/.test(t) ? t : `${t}.`;
}

export function normalize(s: string) {
  return s
    .toLowerCase()
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .replace(/[^\p{L}\p{N}\s]/gu, '')
    .replace(/\s+/g, ' ')
    .trim();
}

export function dedupeKeepOrder<T>(arr: T[]): T[] {
  const seen = new Set<string>();
  const out: T[] = [];
  for (const v of arr) {
    const key = typeof v === 'string' ? normalize(v) : JSON.stringify(v);
    if (!seen.has(key)) {
      seen.add(key);
      out.push(v);
    }
  }
  return out;
}

function joinOneLine(lines: string[]): string {
  // Une frases en la misma línea separadas por espacio (ya llevan punto final)
  return lines.join(' ');
}

/* Extrae y aparta de un array las líneas que cumplan un regex */
function extractByRegex(lines: string[], rx: RegExp): string[] {
  const pick: string[] = [];
  for (let i = lines.length - 1; i >= 0; i--) {
    if (rx.test(lines[i])) {
      pick.unshift(lines[i]);
      lines.splice(i, 1);
    }
  }
  return pick;
}

/* ------------------------ clasificación por secciones ------------------------ */

/** Mapa rápido de palabras clave → sección (fallback si no hay literal exacto) */
const KEYWORDS: Array<{ rx: RegExp; sec: SectionKey }> = [
  // Tórax: mediastino
  { rx: /\bmediast(i|í)n(ic|ic)a|mediast/i, sec: 'thorax.mediastino' },

  // Tórax: vascular
  { rx: /\barteria pulmonar|tep\b|tromboembolismo|defecto de repleci(?:o|ó)n/i, sec: 'thorax.vascular' },

  // Tórax: ganglios (mediastínicos, hiliares, supraclaviculares, axilares)
  { rx: /\b(adenopat(?:i|í)a|ganglio|ganglios).*(mediast|hiliar|supraclav|axilar)/i, sec: 'thorax.ganglios' },

  // Tórax: parénquima
  { rx: /\bpar(e|é)nquima|n[oó]dulo(s)? pulmonar|opacidad|vidrio|mosaico|consolidaci(?:o|ó)n|atelectasia|reticul/i, sec: 'thorax.parenquima' },

  // Tórax: pleura
  { rx: /\bpleur|derrame\b|pleurodesis|engrosamiento pleural/i, sec: 'thorax.pleura' },

  // Hígado
  { rx: /\bh[ií]gado|hep[aá]tic|hepato/i, sec: 'abd.hepatobiliar.higado' },

  // Vasos hepáticos
  { rx: /\bvena porta|suprahep[aá]ticas|esplenoportal/i, sec: 'abd.hepatobiliar.vasos' },

  // Vías biliares / vesícula
  { rx: /\b(v[ií]a biliar|col(e|é)doco|ves[ií]cula|colecist|barro biliar|sludge)\b/i, sec: 'abd.hepatobiliar.vias_ves' },

  // Bazo / páncreas / suprarrenales
  { rx: /\bbazo\b|esplen|p[aá]ncreas|wirsung|suprarrenal|adrenal/i, sec: 'abd.bazo_pancreas_suprarrenal' },

  // Renal y vía urinaria
  { rx: /\briñ(?:o|ó)n|rinon|v[ií]a(s)? urinaria|pielo|hidro|litiasis|microlitiasis|ureter/i, sec: 'abd.renal_uro' },

  // Ganglionar abdominal/pélvico/inguinal/retroperitoneal
  { rx: /\b(adenopat(?:i|í)a|ganglio|ganglios).*(retroperitone|para?a[oó]rtic|intraabdominal|p[ée]lvic|inguin)/i, sec: 'abd.ganglionar' },

  // Peritoneo / mesenterio
  { rx: /\bperitoneo|peritoneal|mesenterio|mesent[eé]ric|carcinomatosis|neumoperitoneo|colecci(?:o|ó)n|ascitis|grasa mesent/i, sec: 'abd.peritoneo_mesenterio' },
];

/**
 * Clasifica una línea a una sección anatómica.
 * - Primero intenta por literales exactos (si se pasan en options).
 * - Si no, usa KEYWORDS.
 */
export function classifyLine(
  line: string,
  literalsBySection?: PostprocessOptions['literalsBySection']
): SectionKey {
  const ln = line.trim();
  if (!ln) return 'unknown';

  if (literalsBySection) {
    for (const [sec, arr] of Object.entries(literalsBySection) as Array<[SectionKey, string[]]>) {
      if (!arr) continue;
      for (const lit of arr) {
        if (ln === lit.trim()) return sec;
      }
    }
  }

  for (const k of KEYWORDS) {
    if (k.rx.test(ln)) return k.sec;
  }
  return 'unknown';
}

/* ------------------------ núcleo de postproceso ------------------------ */

/**
 * Reagrupa/ordena líneas si templateMode está activo.
 * Devuelve SIEMPRE un array de líneas (con punto final).
 */
export function applyPostprocessNorms(
  lines: string[],
  opts: PostprocessOptions = {}
): string[] {
  const clean = dedupeKeepOrder(lines.map(ensureDot));

  // Separamos explícitamente el cierre
  const out = [...clean];
  let closing = '';
  for (let i = out.length - 1; i >= 0; i--) {
    if (/^Sin otros hallazgos\.$/i.test(out[i])) {
      closing = out[i];
      out.splice(i, 1);
      break;
    }
  }

  if (!opts.templateMode) {
    // Sin reagrupación: devolvemos tal cual + cierre si lo hubiera
    return closing ? [...out, closing] : out;
  }

  // ---- MODO PLANTILLA: bucket sort por secciones reales ----
  const buckets = new Map<SectionKey, string[]>();
  SECTION_ORDER.forEach(k => buckets.set(k, []));

  // Clasificar cada línea
  for (const l of out) {
    const sec = classifyLine(l, opts.literalsBySection);
    buckets.get(sec)!.push(l);
  }

  // Algunas normalizaciones dentro de grupos:
  // 1) Si en hígado se coló alguna frase vascular, muévela a "vasos"
  const spillToVessels = extractByRegex(buckets.get('abd.hepatobiliar.higado')!, /\b(vena porta|suprahep[aá]ticas|esplenoportal)\b/i);
  buckets.get('abd.hepatobiliar.vasos')!.push(...spillToVessels);

  // Ensamblado según SECTION_ORDER
  const regrouped: string[] = [];
  for (const key of SECTION_ORDER) {
    const arr = buckets.get(key)!;
    if (!arr.length) continue;
    regrouped.push(...arr);
  }

  // Añadimos el cierre al final, si existía
  if (closing) regrouped.push(closing);

  return regrouped;
}

/* ------------------------ formato final con SALTOS ------------------------ */

/**
 * Aplica el FORMATO de párrafos dentro de HALLAZGOS:
 *  - Párrafos (líneas unidas en la misma línea) en el orden clínico.
 *  - Salto simple entre párrafos, EXCEPTO doble entre:
 *      **pleura**  →  **hígado**
 *  - “Sin otros hallazgos.” en línea propia al final.
 */
export function formatFindings(lines: string[]): string {
  // Aseguramos punto y sin duplicados triviales
  const clean = dedupeKeepOrder(lines.map(ensureDot));

  // Preparamos buckets para producir párrafos
  const bySection = new Map<SectionKey, string[]>();
  SECTION_ORDER.forEach(k => bySection.set(k, []));

  // Separa y retira el cierre si estuviera
  let hasClosing = false;
  for (let i = clean.length - 1; i >= 0; i--) {
    if (/^Sin otros hallazgos\.$/i.test(clean[i])) {
      clean.splice(i, 1);
      hasClosing = true;
      break;
    }
  }

  // Clasifica (sin reordenar aquí; asumimos applyPostprocessNorms ya agrupó si templateMode)
  for (const l of clean) {
    const sec = classifyLine(l);
    bySection.get(sec)!.push(l);
  }

  // Construimos los "párrafos" (cada párrafo = líneas de una sección en misma línea)
  type Para = { section: SectionKey; text: string };
  const paras: Para[] = [];

  for (const sec of SECTION_ORDER) {
    const arr = bySection.get(sec)!;
    if (!arr.length) continue;
    paras.push({ section: sec, text: joinOneLine(arr) });
  }

  // Insertamos el cierre como último "párrafo" en línea propia
  if (hasClosing) paras.push({ section: 'unknown', text: 'Sin otros hallazgos.' });

  // Reglas de salto:
  // - Salto simple '\n' entre todos los párrafos
  // - EXCEPCIÓN: doble salto entre el párrafo cuya sección es 'thorax.pleura'
  //              y el siguiente (que será hígado si existe)
  let out = '';
  for (let i = 0; i < paras.length; i++) {
    out += paras[i].text;
    const isLast = i === paras.length - 1;
    if (isLast) break;

    const currentIsPleura = paras[i].section === 'thorax.pleura';
    if (currentIsPleura) {
      out += '\n\n'; // ← único doble salto dentro de HALLAZGOS
    } else {
      out += '\n';
    }
  }

  return out;
}

src/App.tsx (archivo completo)
// src/App.tsx
import { useMemo, useState } from 'react';

// Datos estructurados
import normalPhrases from './data/normalPhrases.json';
import findingsJson from './data/findings.json';
import fuzzyLexicon from './data/fuzzyLexicon.json';
import presets from './data/presets.json';

// Helpers de plantillas (TÍTULO/TÉCNICA/HALLAZGOS)
import {
  buildReportTitle,
  buildTechniqueBlock,
  buildHallazgosHeader,
  getSelectedRegions,
  getSelectedContrast,
  type RegionTag,
  type ContrastTag,
} from './prompts/templates';

// Postproceso (aplica normas + formateo final)
import { applyPostprocessNorms, formatFindings, ensureDot } from './utils/postprocess';

// Literales/constantes
import { DEFAULT_CLOSING_TEXT } from './config/constants';

// =========================
// Tipos locales
// =========================
type NormalPhrase = {
  text: string;
  regions: string[];
  contrast: string[]; // 'SIEMPRE' | 'CON CONTRASTE' | 'SIN CONTRASTE'
};

type FindingEntry = {
  zona_anatomica: string;
  frase_normal: string; // puede ser "Null." en zona Otros
  hallazgos_patologicos: string[];
  hallazgos_adicionales: string[];
};

type FuzzyEntry = {
  frase_normal: string; // puede estar vacío o "No hay ninguna frase normal..."
  hallazgo_oficial: string;
  sinonimos?: string[];
  errores_comunes?: string[];
  excluir?: string[]; // términos a NO mapear
};

// =========================
// Utilidades internas
// =========================

const SENTENCE_SPLIT = /[.]+|\n+/g;

function normalize(s: string) {
  return s
    .toLowerCase()
    .normalize('NFD') // separa acentos
    .replace(/\p{Diacritic}/gu, '')
    .replace(/[^\p{L}\p{N}\s]/gu, '')
    .replace(/\s+/g, ' ')
    .trim();
}

// Construye catálogo de hallazgos → { tipo, zona, frase_normal }
function buildFindingCatalog(findingTable: FindingEntry[]) {
  const pathological = new Map<string, { zona: string; fraseNormal: string }>();
  const additional = new Map<string, { zona: string; fraseNormal: string }>();

  for (const row of findingTable) {
    const base = { zona: row.zona_anatomica, fraseNormal: row.frase_normal };
    for (const hp of row.hallazgos_patologicos || []) {
      pathological.set(normalize(hp), base);
    }
    for (const ha of row.hallazgos_adicionales || []) {
      additional.set(normalize(ha), base);
    }
  }
  return { pathological, additional };
}

// Construye diccionario fuzzy (sinónimo/errata) → hallazgo_oficial
function buildFuzzyIndex(fuzzyTable: FuzzyEntry[]) {
  const index = new Map<string, { oficial: string; excluir?: string[]; fraseNormal?: string }>();
  for (const e of fuzzyTable) {
    const target = e.hallazgo_oficial?.trim();
    if (!target) continue;

    const pack = { oficial: target, excluir: e.excluir, fraseNormal: e.frase_normal };
    index.set(normalize(target), pack);

    for (const s of e.sinonimos || []) index.set(normalize(s), pack);
    for (const err of e.errores_comunes || []) index.set(normalize(err), pack);
  }
  return index;
}

function contrastMatches(needed: string[], studyContrast: ContrastTag | null) {
  if (needed.includes('SIEMPRE')) return true;
  if (!studyContrast) return false;
  return needed.includes(studyContrast);
}

function regionsMatch(needed: string[], studyRegions: RegionTag[]) {
  // La frase se incluye si alguno de sus regions aparece en studyRegions
  const set = new Set(studyRegions);
  return needed.some(r => set.has(r as RegionTag));
}

/**
 * Filtra la PLANTILLA BASE de frases normales según etiquetas (región/contraste).
 * Mantiene SOLO las frases aplicables al estudio (obligatorio).
 */
function buildBaseTemplate(
  allNormals: NormalPhrase[],
  regions: RegionTag[],
  contrast: ContrastTag | null
) {
  const lines: string[] = [];
  for (const row of allNormals) {
    const okRegion = regionsMatch(row.regions, regions);
    const okContrast = contrastMatches(row.contrast, contrast);
    if (okRegion && okContrast) {
      lines.push(ensureDot(row.text.trim()));
    }
  }
  return lines;
}

// Inserta "Sin otros hallazgos." si no existe ya
function ensureClosing(lines: string[]) {
  const closing = (DEFAULT_CLOSING_TEXT || 'Sin otros hallazgos.').trim();
  const has = lines.some(l => normalize(l) === normalize(closing));
  return has ? lines : [...lines, ensureDot(closing)];
}

function splitTags(s: string): string[] {
  // admite formatos como "[TC-TORAX] [CON CONTRASTE]" o solo texto
  const inBrackets = Array.from(s.matchAll(/\[([^\]]+)\]/g)).map(m => m[1]);
  if (inBrackets.length) return inBrackets;
  return s.split(/[\s,;]+/).filter(Boolean);
}

/* =========================
   Clasificador de TIPO DE TC -> etiquetas
   Se usa la PRIMERA frase del dictado para generar las etiquetas automáticamente.
========================= */

function inferTagsFromFirstSentence(first: string): string[] {
  const t = normalize(first);

  const tags: string[] = [];

  // Región
  const isTorax   = /\btorax|t[oó]rax\b/.test(t);
  const isAbdomen = /\babdomen\b/.test(t);
  const isTAbd    = /\btorax.*abdomen|abdomen.*torax|t[oó]rax.*abdomen/.test(t);

  if (isTAbd) {
    tags.push('[TC-TORAX]', '[TC-ABDOMEN]');
  } else if (isTorax) {
    tags.push('[TC-TORAX]');
  } else if (isAbdomen) {
    tags.push('[TC-ABDOMEN]');
  }

  // Contraste
  const hasContrast =
    /\bcon contraste|contrastado|ev\.?|ev\b/.test(t);
  const noContrast =
    /\bsin contraste|simple\b/.test(t);

  if (hasContrast) tags.push('[CON CONTRASTE]');
  else if (noContrast) tags.push('[SIN CONTRASTE]');

  return tags;
}

/* =========================
   Componente principal
========================= */
export default function App() {
  // UI popup simple: un solo textarea para dictado completo
  const [dictado, setDictado] = useState<string>('');
  const [report, setReport] = useState<string>('');

  // Índices secundarios
  const findingCatalog = useMemo(() => buildFindingCatalog(findingsJson as FindingEntry[]), []);
  const fuzzyIndex = useMemo(() => buildFuzzyIndex(fuzzyLexicon as FuzzyEntry[]), []);

  function handleGenerate() {
    // Separamos frases por punto/retorno
    const parts = (dictado.match(SENTENCE_SPLIT) ? dictado.split(SENTENCE_SPLIT) : [dictado])
      .map(x => x.trim())
      .filter(Boolean);

    if (parts.length === 0) {
      setReport('');
      return;
    }

    // 1) La primera frase es el TIPO de TC → inferimos etiquetas
    const firstSentence = parts[0];
    const autoTags = inferTagsFromFirstSentence(firstSentence);
    const regions = getSelectedRegions(splitTags(autoTags.join(' ')));
    const contrast = getSelectedContrast(splitTags(autoTags.join(' ')));

    // 2) Plantilla base (frases normales) a partir de etiquetas
    let working = buildBaseTemplate(normalPhrases as NormalPhrase[], regions, contrast);

    // 3) Hallazgos: resto de frases (incluye posible "Valida frases normales")
    const rest = parts.slice(1);
    const forceTemplate = rest.some(x => /valida frases normales/i.test(x));

    // Parsear cada hallazgo y ubicarlo
    type MappedFinding = {
      tipo: 'patologico' | 'adicional' | 'suelto';
      zona?: string;
      fraseNormal?: string;
      texto: string;
      oficial?: string;
    };

    const mapped: MappedFinding[] = [];

    for (const raw of rest) {
      if (/valida frases normales/i.test(raw)) continue; // no es hallazgo

      const n = normalize(raw);
      if (!n) continue;

      let mf: MappedFinding | null = null;

      // exact match patológico
      const hitPat = findingCatalog.pathological.get(n);
      if (hitPat) {
        mf = { tipo: 'patologico', zona: hitPat.zona, fraseNormal: hitPat.fraseNormal, texto: ensureDot(raw) };
      }

      // exact match adicional
      if (!mf) {
        const hitAdd = findingCatalog.additional.get(n);
        if (hitAdd) {
          mf = { tipo: 'adicional', zona: hitAdd.zona, fraseNormal: hitAdd.fraseNormal, texto: ensureDot(raw) };
        }
      }

      // fuzzy
      if (!mf) {
        const fz = fuzzyIndex.get(n);
        if (fz && !(fz.excluir || []).some(ex => normalize(ex) === n)) {
          const oficialN = normalize(fz.oficial);
          const hitPat2 = findingCatalog.pathological.get(oficialN);
          const hitAdd2 = findingCatalog.additional.get(oficialN);
          if (hitPat2) {
            mf = { tipo: 'patologico', zona: hitPat2.zona, fraseNormal: hitPat2.fraseNormal, texto: ensureDot(fz.oficial), oficial: fz.oficial };
          } else if (hitAdd2) {
            mf = { tipo: 'adicional', zona: hitAdd2.zona, fraseNormal: hitAdd2.fraseNormal, texto: ensureDot(fz.oficial), oficial: fz.oficial };
          }
        }
      }

      // suelto
      if (!mf) mf = { tipo: 'suelto', texto: ensureDot(raw) };

      mapped.push(mf);
    }

    // 4) Integración sobre la plantilla
    const addQueueByNormal = new Map<string, string[]>(); // frase normal → [adicionales...]
    const replaceByNormal = new Map<string, string>();    // frase normal → patológico final
    const looseFindings: string[] = [];

    for (const mf of mapped) {
      if (mf.tipo === 'adicional' && mf.fraseNormal) {
        const list = addQueueByNormal.get(mf.fraseNormal) || [];
        list.push(mf.texto);
        addQueueByNormal.set(mf.fraseNormal, list);
      } else if (mf.tipo === 'patologico' && mf.fraseNormal) {
        replaceByNormal.set(mf.fraseNormal, mf.texto);
      } else if (mf.tipo === 'suelto') {
        looseFindings.push(mf.texto);
      }
    }

    // Reemplazos patológicos
    working = working
      .map(line => {
        const rep = replaceByNormal.get(line);
        return rep ? rep : line;
      })
      .filter(Boolean);

    // Adicionales detrás de su línea
    working = working.flatMap(line => {
      const rep = replaceByNormal.get(line);
      if (rep) {
        const adds = addQueueByNormal.get(line) || [];
        return [rep, ...adds];
      } else {
        const adds = addQueueByNormal.get(line) || [];
        if (adds.length) return [line, ...adds];
        return [line];
      }
    });

    // Añadir sueltos antes de cierre
    working = ensureClosing(working);
    if (looseFindings.length) {
      const closing = (DEFAULT_CLOSING_TEXT || 'Sin otros hallazgos.').trim();
      const idx = working.findIndex(l => normalize(l) === normalize(closing));
      if (idx === -1) {
        working.push(...looseFindings);
      } else {
        working.splice(idx, 0, ...looseFindings);
      }
    }

    // 5) Reagrupación/orden clínico si “Valida frases normales.”
    working = applyPostprocessNorms(working, { templateMode: forceTemplate });

    // 6) Formato final de HALLAZGOS con saltos pedidos
    const body = formatFindings(working);

    // 7) Título y técnica
    const title = buildReportTitle(regions, contrast);
    const technique = buildTechniqueBlock(regions, contrast);

    const finalText =
      `${title}\n\n` +         // ← doble salto tras TÍTULO
      `${technique}\n\n` +     // ← doble salto tras TÉCNICA
      `${buildHallazgosHeader()}\n` + // “HALLAZGOS:” + salto simple
      `${body}`;

    setReport(finalText);
  }

  return (
    <div className="app" style={{ maxWidth: 640, margin: '40px auto', padding: '0 16px', fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial' }}>
      <h1 style={{ fontSize: 20, marginBottom: 8 }}>Generador de informes TC</h1>
      <p style={{ marginTop: 0, color: '#666' }}>
        Pega el <strong>dictado completo</strong> (1ª frase = tipo de TC). Termina con <em>“Valida frases normales.”</em> si quieres reordenado/agrupación.
      </p>

      <label style={{ fontWeight: 600 }}>Dictado</label>
      <textarea
        placeholder="TC de tórax con contraste. Nódulo pulmonar... Valida frases normales."
        value={dictado}
        onChange={e => setDictado(e.target.value)}
        rows={10}
        style={{ width: '100%', marginTop: 6 }}
      />

      <button
        onClick={handleGenerate}
        style={{
          marginTop: 12,
          padding: '10px 16px',
          border: '1px solid #ccc',
          borderRadius: 8,
          cursor: 'pointer',
          background: '#111',
          color: '#fff',
          fontWeight: 600,
        }}
      >
        Generar informe
      </button>

      <div style={{ marginTop: 24 }}>
        <label style={{ fontWeight: 600 }}>Informe final</label>
        <textarea
          readOnly
          value={report}
          rows={20}
          style={{ width: '100%', marginTop: 6 }}
        />
      </div>

      <div style={{ marginTop: 12, fontSize: 12, color: '#888' }}>
        <div>Presets: {Array.isArray(presets) ? presets.length : 0}</div>
        <div>Frases normales: {Array.isArray(normalPhrases) ? normalPhrases.length : 0}</div>
        <div>Bloques de hallazgos: {Array.isArray(findingsJson) ? findingsJson.length : 0}</div>
        <div>Entrada fuzzy: {Array.isArray(fuzzyLexicon) ? fuzzyLexicon.length : 0}</div>
      </div>
    </div>
  );
}

Qué cambia exactamente

formatFindings ahora impone los saltos:

Doble salto únicamente entre el párrafo de pleura y el de hígado.

Salto simple entre todos los demás bloques.

“Sin otros hallazgos.” siempre en línea propia al final.

applyPostprocessNorms reagrupa y ordena secciones solo si el dictado contiene “Valida frases normales.”.

App.tsx usa ahora formatFindings(working) en lugar de working.join(' '), de modo que el formato final cumpla tu plantilla.

Pega estos dos archivos tal cual y debería respetarse tu maquetación de informe exactamente como la especificaste.