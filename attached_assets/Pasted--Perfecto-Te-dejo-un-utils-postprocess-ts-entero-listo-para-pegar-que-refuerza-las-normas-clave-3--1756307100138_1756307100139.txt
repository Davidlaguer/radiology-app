¡Perfecto! Te dejo un utils/postprocess.ts entero listo para pegar que refuerza las normas clave (3, 4, 8), agrupa por secciones anatómicas reales en template mode, elimina contradicciones típicas (nódulos/adenopatías/colelitiasis/litiasis renal vs frases normales), deduplica el cierre y normaliza el texto.

Además, al final te dejo un set de dictados de prueba para que los pegues tal cual en Replit y veas el antes/después.

Importa así en tu App.tsx:
import { applyPostprocessNorms } from "./utils/postprocess";

utils/postprocess.ts (reemplaza el archivo entero)
// src/utils/postprocess.ts

/**
 * Postproceso de líneas para el informe:
 * - Elimina contradicciones (Norma 3) típicas: nódulo pulmonar, adenopatías, colelitiasis, litiasis renal…
 * - Modificación parcial de normales (Norma 8) para hallazgos benignos en hígado (“otras lesiones…”).
 * - Deduplica y garantiza “Sin otros hallazgos.” al final.
 * - Modo plantilla: reagrupa por secciones en orden anatómico estable.
 */

export type PostprocessOptions = {
  templateMode?: boolean;     // Activa la reagrupación/orden anatómico (Norma 11)
  literals?: string[];        // (Opcional) Literales de tus frases normales, si quieres afinar el clasificador
  closingLiteral?: string;    // Por defecto: "Sin otros hallazgos."
};

// -------------------------------
// Utils básicos
// -------------------------------
const SENTENCE_END = /[.:]$/;
const DEFAULT_CLOSING = "Sin otros hallazgos.";

function ensureDot(s: string): string {
  const t = s.trim();
  if (!t) return t;
  return SENTENCE_END.test(t) ? t : `${t}.`;
}
function normalize(s: string) {
  return s
    .toLowerCase()
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .replace(/[^\p{L}\p{N}\s]/gu, "")
    .replace(/\s+/g, " ")
    .trim();
}
function eq(a: string, b: string) {
  return normalize(a) === normalize(b);
}

// -------------------------------
// Reglas: detección de contradicciones
// (Si aparece el hallazgo, se eliminan estas frases normales)
// -------------------------------

/**
 * Las claves son regex que detectan el hallazgo patológico en la línea.
 * Los valores son arrays de regex de frases normales a quitar si el hallazgo está presente.
 */
const CONTRADICTION_RULES: Array<{
  trigger: RegExp;      // hallazgo patológico que aparece en la línea final
  dropNormals: RegExp[]; // normales a eliminar (contradicciones)
}> = [
  // Pulmón / Parénquima
  {
    trigger: /\bn[oó]dulo(s)? pulmonar(es)?\b|\bespiculad[oa]\b/i,
    dropNormals: [
      /par[eé]nquima pulmonar sin alteraciones a destacar/i,
      /no se observan condensaciones de espacio a[eé]reo ni n[oó]dulos pulmonares/i,
    ],
  },
  // Adenopatías torácicas (mediastínicas/hiliares) y axilares
  {
    trigger: /\badenopat[ií]a(s)? (mediast[ií]nica(s)?|hiliar(es)?|axilar(es)?|supraclaviculares?)\b.*\b(aumentad[ao]s?|de \d+ ?mm)/i,
    dropNormals: [
      /no se observan adenopat[ií]as mediast[ií]nicas o hiliares aumentadas de tama/i,
      /no se observan adenopat[ií]as supraclaviculares o axilares aumentadas de tama/i,
    ],
  },
  // Adenopatías intraabdominales/pélvicas/inguinales
  {
    trigger: /\badenopat[ií]a(s)?\b.*\bretroperitoneal|mesent[eé]rica|para(a|o)[ó]rtica|iliac[ao]s?|p[eé]lvic[ao]s?|inguinal(es)?\b.*(aumentad|de \d+ ?mm)/i,
    dropNormals: [
      /no se observan adenopat[ií]as intraabdominales aumentadas de tama/i,
      /no se observan adenopat[ií]as p[eé]lvicas o inguinales aumentadas de tama/i,
    ],
  },
  // Vesícula biliar
  {
    trigger: /\bcolelitiasis\b|litiasis (vesicular|biliar)/i,
    dropNormals: [
      /ves[ií]cula biliar sin evidencia de litiasis en su interior, engrosamientos murales o signos inflamatorios agudos/i,
    ],
  },
  // Riñón / litiasis
  {
    trigger: /\b(litiasis|microlitiasis|c[aá]lculo(s)?) (renal(es)?|en riñ[oó]n|pielo[^\s]*|ureter(a|al)?)\b/i,
    dropNormals: [
      /no se observan lesiones focales ni dilataci[oó]n de la v[ií]a urinaria (derecha|izquierda)?/i,
    ],
  },
  // Derrame pleural
  {
    trigger: /\bderrame (pleural)?\b/i,
    dropNormals: [/espacios pleurales libres/i],
  },
  // Bocio / Patología tiroidea => quita normal si la hubiera (si tienes una línea de “tiroides normal”)
  {
    trigger: /\bbocio\b|\bpatolog[ií]a tiroidea\b|\bn[oó]dulo tiroideo\b/i,
    dropNormals: [
      // Si más adelante añades una frase normal explícita de tiroides, pon aquí su regex exacto.
      // Ejemplo: /tiroides de tama/i,
    ],
  },
];

// -------------------------------
// Modificaciones parciales (Norma 8)
// Si hay quistes/hemangiomas hepáticos → “No se observan otras lesiones focales hepáticas.”
// -------------------------------
const HEPATIC_BENIGN_TRIGGERS = /\b(hemangioma(s)?|quiste(s)? hep[aá]tico(s)?)\b/i;
const HEPATIC_FOCAL_NEGATIVE = /no se observan lesiones focales hep[aá]ticas/i;
const HEPATIC_FOCAL_NEGATIVE_REPLACEMENT =
  "No se observan otras lesiones focales hepáticas.";

// -------------------------------
// Cierre
// -------------------------------
function ensureSingleClosing(lines: string[], closing = DEFAULT_CLOSING): string[] {
  const tgt = closing.trim();
  const out: string[] = [];
  let has = false;
  for (const l of lines) {
    if (eq(l, tgt)) {
      if (!has) {
        out.push(tgt);
        has = true;
      }
    } else {
      out.push(l);
    }
  }
  if (!has) out.push(tgt);
  return out;
}

// -------------------------------
// Modo plantilla: orden anatómico real
// -------------------------------

/**
 * Orden de secciones anatómicas (buckets) para TC Tórax / Abdomen.
 * Ajusta/expande a tu gusto. Las claves son internas y las usamos en classifyLine.
 */
const SECTION_ORDER = [
  // TÓRAX
  "thorax.mediastino",
  "thorax.parenquima",
  "thorax.vascular",
  "thorax.pleura",
  "thorax.pared_cuello_tiroides",
  // ABDOMEN
  "abd.hepatobiliar.higado",
  "abd.hepatobiliar.vb_vias",
  "abd.bazo",
  "abd.pancreas",
  "abd.suprarrenales",
  "abd.renal",
  "abd.adenopatias",
  "abd.peritoneo",
  "abd.otro",
] as const;
type SectionKey = (typeof SECTION_ORDER)[number];

function classifyLine(line: string, literals?: string[]): SectionKey {
  const s = normalize(line);

  // Si se nos pasó el set de literales, probemos un atajo simples
  if (literals && literals.some((lit) => eq(lit, line))) {
    // heurística por literal conocida
    if (/mediastin/i.test(s)) return "thorax.mediastino";
    if (/par[eé]nquima|n[oó]dulo(s)? pulmonar/i.test(s)) return "thorax.parenquima";
    if (/arteria pulmonar|tep|aorta|calibre normal/i.test(s)) return "thorax.vascular";
    if (/pleural|pleurodesis|derrame/i.test(s)) return "thorax.pleura";
    if (/tiroid/i.test(s)) return "thorax.pared_cuello_tiroides";

    if (/h[ií]gado|hep[aá]tic/i.test(s)) return "abd.hepatobiliar.higado";
    if (/ves[ií]cula|biliar|col[eé]doco/i.test(s)) return "abd.hepatobiliar.vb_vias";
    if (/bazo|esplen/i.test(s)) return "abd.bazo";
    if (/p[aá]ncreas|wirsung/i.test(s)) return "abd.pancreas";
    if (/suprarrenal|adrenal/i.test(s)) return "abd.suprarrenales";
    if (/riñ[oó]n|renal|v[ií]a urinaria|pielo|ur[eé]ter/i.test(s)) return "abd.renal";
    if (/adenopat[ií]a|ganglio/i.test(s)) return "abd.adenopatias";
    if (/colecci[oó]n|ascitis|neumoperitoneo|carcinomatosis/i.test(s)) return "abd.peritoneo";
    return "abd.otro";
  }

  // Clasificación por keywords seguras
  if (/mediastin/i.test(s)) return "thorax.mediastino";
  if (/par[eé]nquima|n[oó]dulo(s)? pulmonar|vidrio|atelect|mosaico|trapping/i.test(s))
    return "thorax.parenquima";
  if (/arteria pulmonar|tep|aorta/i.test(s)) return "thorax.vascular";
  if (/pleural|pleurodesis|derrame/i.test(s)) return "thorax.pleura";
  if (/tiroid|pared tor[aá]cica|clavicular|axilar|supraclav/i.test(s))
    return "thorax.pared_cuello_tiroides";

  if (/h[ií]gado|hep[aá]tic/i.test(s)) return "abd.hepatobiliar.higado";
  if (/ves[ií]cula|biliar|col[eé]doco|colelitiasis/i.test(s)) return "abd.hepatobiliar.vb_vias";
  if (/bazo|esplen/i.test(s)) return "abd.bazo";
  if (/p[aá]ncreas|wirsung|quiste.*pancre[aá]tico/i.test(s)) return "abd.pancreas";
  if (/suprarrenal|adrenal/i.test(s)) return "abd.suprarrenales";
  if (/riñ[oó]n|renal|v[ií]a urinaria|pielo|ur[eé]ter|litiasis/i.test(s)) return "abd.renal";
  if (/adenopat[ií]a|ganglio/i.test(s)) return "abd.adenopatias";
  if (/colecci[oó]n|ascitis|neumoperitoneo|carcinomatosis|trabecul/i.test(s))
    return "abd.peritoneo";

  return "abd.otro";
}

function reorderBySections(lines: string[], literals?: string[]): string[] {
  const buckets = new Map<SectionKey, string[]>();
  for (const k of SECTION_ORDER) buckets.set(k, []);
  for (const line of lines) {
    const key = classifyLine(line, literals);
    buckets.get(key)!.push(line);
  }
  const result: string[] = [];
  for (const k of SECTION_ORDER) {
    const arr = buckets.get(k)!;
    if (arr.length) result.push(...arr);
  }
  return result;
}

// -------------------------------
// Núcleo: applyPostprocessNorms
// -------------------------------
export function applyPostprocessNorms(
  inputLines: string[],
  options: PostprocessOptions = {}
): string[] {
  const closing = options.closingLiteral?.trim() || DEFAULT_CLOSING;

  // 1) Limpieza básica + asegurar punto final en todas las líneas
  let lines = inputLines
    .map((l) => l.trim())
    .filter(Boolean)
    .map(ensureDot);

  // 2) Eliminar contradicciones:
  //    Si aparece una línea de hallazgo que activa 'trigger',
  //    eliminamos líneas de 'dropNormals' que aún sigan.
  const joinedForScan = lines.join(" ");
  const activeContradictions = CONTRADICTION_RULES.filter((r) => r.trigger.test(joinedForScan));

  if (activeContradictions.length) {
    lines = lines.filter((line) => {
      const n = normalize(line);
      for (const rule of activeContradictions) {
        for (const rx of rule.dropNormals) {
          if (rx.test(line) || rx.test(n)) {
            return false; // drop esta normal
          }
        }
      }
      return true;
    });
  }

  // 3) Modificaciones parciales (Norma 8) para hígado
  if (HEPATIC_BENIGN_TRIGGERS.test(joinedForScan)) {
    lines = lines.map((line) => {
      if (HEPATIC_FOCAL_NEGATIVE.test(line)) return ensureDot(HEPATIC_FOCAL_NEGATIVE_REPLACEMENT);
      return line;
    });
  }

  // 4) Deduplicar y garantizar cierre único al final
  //    Primero eliminamos repeticiones de la misma línea (pasan a menudo al consolidar).
  const seen = new Set<string>();
  lines = lines.filter((l) => {
    const key = normalize(l);
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  // Borrar cierres intermedios y asegurar uno al final
  lines = lines.filter((l) => !eq(l, closing));
  lines = ensureSingleClosing(lines, closing);

  // 5) Modo plantilla (Norma 11): reordenar por secciones anatómicas reales
  if (options.templateMode) {
    lines = reorderBySections(lines, options.literals);
  }

  return lines;
}