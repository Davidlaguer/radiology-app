✅ 1) Nuevo archivo: src/utils/formatter.ts

Crea este archivo tal cual:

// src/utils/formatter.ts
//
// Formateador final del bloque HALLAZGOS:
// - Clasifica cada línea en buckets anatómicos robustos.
// - Elimina frases normales que contradicen a un hallazgo del mismo bucket.
// - Reconstruye el bloque con el ORDEN y SALTOS EXACTOS que pediste:
//   · Doble salto solo entre "pleura" → "hígado" (y, fuera del bloque, tras TÍTULO/TECNICA/HALLAZGOS).
//   · Resto en salto simple.
// - Combina sub-bloques en una sola línea cuando procede (p.ej. mediastino+arteria+TEP; ganglios torácicos; bazo+páncreas+adrenales; riñones).
//
// Nota: trabaja sobre un array de frases “finales” (ya sustituidas/añadidas por tu pipeline).

type BucketKey =
  // TÓRAX
  | 'thorax.mediastino'
  | 'thorax.arteria'
  | 'thorax.tep'
  | 'thorax.adenos.med_hiliares'
  | 'thorax.adenos.axil_supraclav'
  | 'thorax.parenquima'
  | 'thorax.pleura'
  // ABDOMEN
  | 'liver.parenquima'
  | 'liver.vessels'
  | 'biliary.gb'
  | 'spa.bazo'
  | 'spa.pancreas'
  | 'spa.adrenales'
  | 'renal.der'
  | 'renal.izq'
  | 'abd.adenos'
  | 'pelvis.adenos'
  | 'peritoneo'
  // OTROS (sin plantilla)
  | 'otros';

const CLOSING_FALLBACK = 'Sin otros hallazgos.';

// Normalizador
function normalize(s: string) {
  return s
    .toLowerCase()
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .replace(/[^\p{L}\p{N}\s.]/gu, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

// --- Clasificación por keywords seguras ---
function classifyLine(raw: string): BucketKey {
  const n = normalize(raw);

  // Cierre (lo manejamos fuera aquí; si llega, lo enviaremos al final)
  if (n === normalize(CLOSING_FALLBACK)) return 'otros';

  // Tórax
  if (/mediastin|hiliar/i.test(n) && /estructura|significativa|no se observan|adenopati/i.test(n)) {
    // Esta normal suele ir junto a arteria/TEP en G1, pero si es de adenos mediastino/hiliares
    if (/adenopat/i.test(n)) return 'thorax.adenos.med_hiliares';
    return 'thorax.mediastino';
  }
  if (/arteria pulmonar|calibre normal/i.test(n)) return 'thorax.arteria';
  if (/\btep\b|tromboembol|defecto de reple/i.test(n)) return 'thorax.tep';
  if (/supraclavicul|axilar/i.test(n)) return 'thorax.adenos.axil_supraclav';
  if (/parenquima pulmonar|condensacion|condensaciones|nodulos? pulmon/i.test(n) || /n[oó]dulo pulmon/i.test(n)) {
    return 'thorax.parenquima';
  }
  if (/pleural|pleura|derrame/i.test(n)) return 'thorax.pleura';

  // Hígado/vías
  if (/h[ií]gado|hep[aá]tic/i.test(n)) {
    // Venas/porta/esplenoportal
    if (/vena porta|suprahepat|esplenoportal|permeable/i.test(n)) return 'liver.vessels';
    // Vía biliar / vesícula pueden colarse aquí, filtramos abajo
    if (/via biliar|ves[ií]cula/i.test(n)) {
      return 'biliary.gb';
    }
    return 'liver.parenquima';
  }
  // Vía biliar + vesícula explícitas
  if (/via biliar|ves[ií]cula/i.test(n)) return 'biliary.gb';

  // Bazo / páncreas / adrenales
  if (/bazo/i.test(n)) return 'spa.bazo';
  if (/p[aá]ncreas|wirsung/i.test(n)) return 'spa.pancreas';
  if (/suprarrenal|adrenal/i.test(n)) return 'spa.adrenales';

  // Renal / vía urinaria
  if (/ri[nñ][oó]n derech|v[ií]a urinaria derech/i.test(n)) return 'renal.der';
  if (/ri[nñ][oó]n izquierd|v[ií]a urinaria izquierd/i.test(n)) return 'renal.izq';
  if (/ur[eé]ter|urotel/i.test(n)) {
    // No tenemos normal específica de uréter → dejamos que caiga en el bucket renal adecuado por contexto:
    if (/izquierd/i.test(n)) return 'renal.izq';
    if (/derech/i.test(n)) return 'renal.der';
    return 'renal.der'; // por defecto en renal
  }

  // Adenopatías abdomen/pelvis
  if (/adenopat[ií]as? intraabdominal|intra-abdominal/i.test(n)) return 'abd.adenos';
  if (/adenopat[ií]as? p[eé]lvic|inguinal/i.test(n)) return 'pelvis.adenos';

  // Peritoneo / colecciones / neumoperitoneo
  if (/coleccion|neumoperitoneo|l[ií]quido libre intraabdominal|ascitis/i.test(n)) return 'peritoneo';

  // OTROS (mama, tiroides, osteo, vascular extra, ciego, senos, etc.)
  if (/mama|marcador met[aá]lico|tiroid|bocio|columna|vertebr|lesiones [oó]seas|aortoiliac|aortoil[ií]ac|ciego|diverticul|senos? paranasal|sinusal|vejiga|pr[oó]stata/i.test(n)) {
    return 'otros';
  }

  // fallback
  return 'otros';
}

// --- Detección de “normal negadora” para suprimir si hay patología en el bucket ---
const normalMatchersByBucket: Partial<Record<BucketKey, RegExp[]>> = {
  'thorax.mediastino': [/estructuras mediast/i],
  'thorax.arteria': [/arteria pulmonar de calibre normal/i],
  'thorax.tep': [/no se observan signos de tep|no.*defecto de reple/i],
  'thorax.adenos.med_hiliares': [/no se observan adenopat[ií]as mediast[ií]nicas|hiliares/i],
  'thorax.adenos.axil_supraclav': [/no se observan adenopat[ií]as supraclav|axilar/i],
  'thorax.parenquima': [/parenquima pulmonar sin alteraciones|no se observan condensaciones.*nodul/i],
  'thorax.pleura': [/espacios pleurales libres/i],
  'liver.parenquima': [/no se observan lesiones focales hep[aá]ticas/i],
  'liver.vessels': [/vena porta.*permeable|suprahepat|esplenoportal .* permeable/i],
  'biliary.gb': [/no se observa dilataci[oó]n de la v[ií]a biliar|ves[ií]cula biliar sin evidencia de litiasis/i],
  'spa.bazo': [/bazo de tama/i],
  'spa.pancreas': [/p[aá]ncreas de tama/i],
  'spa.adrenales': [/gl[aá]ndulas suprarrenales de tama/i],
  'renal.der': [/ri[nñ][oó]n derecho de tama|no se observan lesiones.*v[ií]a urinaria derecha/i],
  'renal.izq': [/ri[nñ][oó]n izquierdo de tama|no se observan lesiones.*v[ií]a urinaria izquierda/i],
  'abd.adenos': [/no se observan adenopat[ií]as intraabdominal/i],
  'pelvis.adenos': [/no se observan adenopat[ií]as p[eé]lvicas|inguinal/i],
  'peritoneo': [/no se observan colecciones|neumoperitoneo|l[ií]quido libre intraabdominal/i],
};

function looksPathologic(line: string): boolean {
  const n = normalize(line);
  // Palabras que tipifican patología (amplio pero seguro)
  return /adenopat|n[oó]dulo|derrame|opacidad|opacidades|consolidaci[oó]n|quiste|quistes|hemangioma|masa|engrosamiento|hipercapt|tromb|defecto de reple|ectasia|dilataci[oó]n|litiasis|microlitiasis|pielo|uretero|ascitis|colecci[oó]n|carcinomatosis|trabeculaci[oó]n|aortoiliac|aortoil[ií]ac|bocio|tiroid|mama|marcador met[aá]lico|oste|bl[aá]stica|vertebr|met[aá]stasi/i.test(
    n
  );
}

// Suprime normales que contradicen si en el bucket hay patología
function squashContradictoryNormals(lines: string[], bucket: BucketKey) {
  const hasPathology = lines.some(looksPathologic);
  if (!hasPathology) return lines;

  const matchers = normalMatchersByBucket[bucket] || [];
  if (!matchers.length) return lines;

  return lines.filter((l) => !matchers.some((rx) => rx.test(l)));
}

// Orden fijo de grupos y combinación en una sola línea por grupo cuando aplica
const GROUPS: BucketKey[][] = [
  // G1: mediastino + arteria + TEP → 1 línea
  ['thorax.mediastino', 'thorax.arteria', 'thorax.tep'],
  // G2: ganglios mediast/hiliares + axil/supraclav → 1 línea
  ['thorax.adenos.med_hiliares', 'thorax.adenos.axil_supraclav'],
  // G3: parénquima → 1 línea
  ['thorax.parenquima'],
  // G4: pleura → 1 línea
  ['thorax.pleura'],
  // —— doble salto aquí ——
  // G5: hígado (parenquima) → 1 línea
  ['liver.parenquima'],
  // G6: vasos hepáticos → 1 línea
  ['liver.vessels'],
  // G7: vía biliar + vesícula → 1 línea
  ['biliary.gb'],
  // G8: bazo + páncreas + adrenales → 1 línea
  ['spa.bazo', 'spa.pancreas', 'spa.adrenales'],
  // G9: riñón derecho + izquierdo → 1 línea
  ['renal.der', 'renal.izq'],
  // G10: adenopatías abdo + pélvicas/inguinales → 1 línea
  ['abd.adenos', 'pelvis.adenos'],
  // G11: peritoneo/colecciones → 1 línea
  ['peritoneo'],
];

function joinSentencesInline(list: string[]): string | null {
  const trimmed = list.map((s) => s.trim()).filter(Boolean);
  if (!trimmed.length) return null;
  // Unimos frases en una sola línea separadas por espacio (cada frase ya trae su punto).
  return trimmed.join(' ');
}

export function formatHallazgos(
  inputLines: string[],
  opts?: { closingText?: string }
): string {
  const closingText = (opts?.closingText || CLOSING_FALLBACK).trim();

  // 1) Saca el cierre si viniera dentro
  const linesNoClosing = inputLines.filter((l) => normalize(l) !== normalize(closingText));

  // 2) Clasifica por buckets
  const buckets = new Map<BucketKey, string[]>();
  for (const l of linesNoClosing) {
    const b = classifyLine(l);
    const arr = buckets.get(b) || [];
    arr.push(l);
    buckets.set(b, arr);
  }

  // 3) Limpia contradictorias en cada bucket
  for (const [key, arr] of buckets) {
    buckets.set(key, squashContradictoryNormals(arr, key));
  }

  // 4) Ordena renal.der/renal.izq (derecho antes que izquierdo)
  for (const k of ['renal.der', 'renal.izq'] as BucketKey[]) {
    const arr = buckets.get(k);
    if (arr && arr.length > 1) {
      arr.sort((a, b) => {
        const ad = /derech/i.test(a) ? -1 : 0;
        const bd = /derech/i.test(b) ? -1 : 0;
        if (ad !== bd) return ad - bd;
        return a.localeCompare(b);
      });
      buckets.set(k, arr);
    }
  }

  // 5) Reconstruye en el orden fijado, combinando sub-buckets de cada grupo en 1 línea
  const out: string[] = [];
  for (let gi = 0; gi < GROUPS.length; gi++) {
    const group = GROUPS[gi];
    const merged: string[] = [];
    for (const sub of group) {
      const arr = buckets.get(sub);
      if (arr && arr.length) merged.push(...arr);
    }
    const line = joinSentencesInline(merged);
    if (line) out.push(line);

    // Inserta el doble salto EXACTO tras pleura → antes de hígado
    // pleura es G4 (índice 3). Después de procesar G4, insertamos una línea vacía adicional.
    if (gi === 3) out.push(''); // línea vacía = doble salto cuando hagamos join más abajo
  }

  // 6) “Otros” (sin plantilla) → justo antes del cierre
  const otros = buckets.get('otros') || [];
  if (otros.length) {
    // Junta en UNA línea, como venías observando en tus ejemplos finales
    const line = joinSentencesInline(otros);
    if (line) out.push(line);
  }

  // 7) Añade cierre
  out.push(closingText);

  // 8) Render: una línea vacía "" en el array equivale a un doble salto en el texto final.
  //    Para el resto: salto simple por línea.
  return out
    .map((l, i) => {
      if (l === '') return ''; // respetamos línea vacía (doble salto)
      return l;
    })
    .join('\n')
    // Compactamos triples saltos accidentales (por si acaso)
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

✅ 2) Reemplaza por completo tu src/App.tsx

He tomado tu App anterior y le he aplicado:

✅ Ignorar “Sin otros hallazgos.” si viene en el dictado (para que no duplique).

✅ Usar formatHallazgos(...) para construir el bloque “HALLAZGOS” con los saltos/agrupaciones exactos.

✅ Mantener tu lógica de sustitución/añadidos (patológico vs adicional) y “suelto” al final.

✅ Sin cambios en UI (si ya migraste a una sola caja, conserva tu versión; si sigues con 2 cajas, pega este archivo completo).

// src/App.tsx
import { useMemo, useState } from 'react';

// Datos estructurados
import normalPhrases from './data/normalPhrases.json';
import findingsJson from './data/findings.json';
import fuzzyLexicon from './data/fuzzyLexicon.json';
import presets from './data/presets.json';

// Helpers de plantillas
import {
  buildReportTitle,
  buildTechniqueBlock,
  buildHallazgosHeader,
  getSelectedRegions,
  getSelectedContrast,
  type RegionTag,
  type ContrastTag,
} from './prompts/templates';

// Postproceso (normas propias ya existentes en tu repo)
import { applyPostprocessNorms } from './utils/postprocess';

// Constantes
import { DEFAULT_CLOSING_TEXT } from './config/constants';

// NUEVO: formateador final de hallazgos
import { formatHallazgos } from './utils/formatter';

// =========================
// Tipos locales
// =========================
type NormalPhrase = {
  text: string;
  regions: string[];
  contrast: string[]; // 'SIEMPRE' | 'CON CONTRASTE' | 'SIN CONTRASTE'
};

type FindingEntry = {
  zona_anatomica: string;
  frase_normal: string; // puede ser "Null." en zona Otros
  hallazgos_patologicos: string[];
  hallazgos_adicionales: string[];
};

type FuzzyEntry = {
  frase_normal: string; // puede estar vacío o "No hay ninguna frase normal..."
  hallazgo_oficial: string;
  sinonimos?: string[];
  errores_comunes?: string[];
  excluir?: string[]; // opcional
};

// =========================
// Utilidades internas
// =========================

const SENTENCE_SPLIT = /[.]+|\n+/g;

function normalize(s: string) {
  return s
    .toLowerCase()
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .replace(/[^\p{L}\p{N}\s]/gu, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function buildFindingCatalog(findingTable: FindingEntry[]) {
  const pathological = new Map<string, { zona: string; fraseNormal: string }>();
  const additional = new Map<string, { zona: string; fraseNormal: string }>();

  for (const row of findingTable) {
    const base = { zona: row.zona_anatomica, fraseNormal: row.frase_normal };
    for (const hp of row.hallazgos_patologicos || []) {
      pathological.set(normalize(hp), base);
    }
    for (const ha of row.hallazgos_adicionales || []) {
      additional.set(normalize(ha), base);
    }
  }
  return { pathological, additional };
}

function buildFuzzyIndex(fuzzyTable: FuzzyEntry[]) {
  const index = new Map<string, { oficial: string; excluir?: string[]; fraseNormal?: string }>();
  for (const e of fuzzyTable) {
    const target = e.hallazgo_oficial?.trim();
    if (!target) continue;

    const pack = { oficial: target, excluir: e.excluir, fraseNormal: e.frase_normal };
    index.set(normalize(target), pack);

    for (const s of e.sinonimos || []) index.set(normalize(s), pack);
    for (const err of e.errores_comunes || []) index.set(normalize(err), pack);
  }
  return index;
}

function contrastMatches(needed: string[], studyContrast: ContrastTag | null) {
  if (needed.includes('SIEMPRE')) return true;
  if (!studyContrast) return false;
  return needed.includes(studyContrast);
}

function regionsMatch(needed: string[], studyRegions: RegionTag[]) {
  const set = new Set(studyRegions);
  return needed.some((r) => set.has(r as RegionTag));
}

/**
 * Filtra la PLANTILLA BASE de frases normales según etiquetas.
 */
function buildBaseTemplate(
  allNormals: NormalPhrase[],
  regions: RegionTag[],
  contrast: ContrastTag | null
) {
  const lines: string[] = [];
  for (const row of allNormals) {
    const okRegion = regionsMatch(row.regions, regions);
    const okContrast = contrastMatches(row.contrast, contrast);
    if (okRegion && okContrast) {
      lines.push(row.text.trim());
    }
  }
  return lines;
}

function ensureDot(s: string) {
  const t = s.trim();
  if (!t) return t;
  return /[.:]$/.test(t) ? t : `${t}.`;
}

function ensureClosing(lines: string[]) {
  const closing = (DEFAULT_CLOSING_TEXT || 'Sin otros hallazgos.').trim();
  const has = lines.some((l) => normalize(l) === normalize(closing));
  return has ? lines : [...lines, closing];
}

function splitTags(s: string): string[] {
  const inBrackets = Array.from(s.matchAll(/\[([^\]]+)\]/g)).map((m) => m[1]);
  if (inBrackets.length) return inBrackets;
  return s.split(/[\s,;]+/).filter(Boolean);
}

// =========================
// Componente principal (UI básica de prueba)
// =========================
export default function App() {
  // UI (si ya migraste a una sola caja, puedes mantenerla;
  // este App conserva dos campos para no romperte el flujo de pruebas)
  const [labelsRaw, setLabelsRaw] = useState<string>('');
  const [findingsRaw, setFindingsRaw] = useState<string>('');
  const [report, setReport] = useState<string>('');

  // Índices memoizados
  const regions = useMemo<RegionTag[]>(
    () => getSelectedRegions(splitTags(labelsRaw)),
    [labelsRaw]
  );
  const contrast = useMemo<ContrastTag | null>(
    () => getSelectedContrast(splitTags(labelsRaw)),
    [labelsRaw]
  );
  const technique = useMemo(() => buildTechniqueBlock(regions, contrast), [regions, contrast]);
  const title = useMemo(() => buildReportTitle(regions, contrast), [regions, contrast]);

  const findingCatalog = useMemo(() => buildFindingCatalog(findingsJson as FindingEntry[]), []);
  const fuzzyIndex = useMemo(() => buildFuzzyIndex(fuzzyLexicon as FuzzyEntry[]), []);

  function handleGenerate() {
    // 1) Plantilla base según etiquetas
    let baseLines = buildBaseTemplate(normalPhrases as NormalPhrase[], regions, contrast);

    // 2) Procesar dictado (segundo mensaje)
    const dictado = findingsRaw || '';
    const rawItems = (dictado.match(SENTENCE_SPLIT) ? dictado.split(SENTENCE_SPLIT) : [dictado])
      .map((x) => x.trim())
      .filter(Boolean);

    // Detectar MODO PLANTILLA por texto (“Valida frases normales.”)
    const templateMode = rawItems.some((x) => normalize(x).includes('valida frases normales'));

    type MappedFinding = {
      tipo: 'patologico' | 'adicional' | 'suelto';
      zona?: string;
      fraseNormal?: string;
      texto: string;
      oficial?: string;
    };

    const mapped: MappedFinding[] = [];

    for (const itemRaw of rawItems) {
      const item = itemRaw.trim();
      const n = normalize(item);
      if (!n) continue;

      // Ignora activadores/cierras escritos por el usuario
      if (n.includes('valida frases normales')) continue;
      if (n === normalize(DEFAULT_CLOSING_TEXT || 'Sin otros hallazgos.')) continue;

      // 2.a) exact match en tablas
      let mf: MappedFinding | null = null;

      if (!mf) {
        const hitPat = findingCatalog.pathological.get(n);
        if (hitPat) mf = { tipo: 'patologico', zona: hitPat.zona, fraseNormal: hitPat.fraseNormal, texto: ensureDot(item) };
      }
      if (!mf) {
        const hitAdd = findingCatalog.additional.get(n);
        if (hitAdd) mf = { tipo: 'adicional', zona: hitAdd.zona, fraseNormal: hitAdd.fraseNormal, texto: ensureDot(item) };
      }

      // 2.b) fuzzy → oficial → buscar en catálogo
      if (!mf) {
        const fz = fuzzyIndex.get(n);
        if (fz && !(fz.excluir || []).some((ex) => normalize(ex) === n)) {
          const oficialN = normalize(fz.oficial);
          const hitPat = findingCatalog.pathological.get(oficialN);
          const hitAdd = findingCatalog.additional.get(oficialN);
          if (hitPat)
            mf = {
              tipo: 'patologico',
              zona: hitPat.zona,
              fraseNormal: hitPat.fraseNormal,
              texto: ensureDot(fz.oficial),
              oficial: fz.oficial,
            };
          else if (hitAdd)
            mf = {
              tipo: 'adicional',
              zona: hitAdd.zona,
              fraseNormal: hitAdd.fraseNormal,
              texto: ensureDot(fz.oficial),
              oficial: fz.oficial,
            };
        }
      }

      if (!mf) {
        // suelto (sin plantilla) → irá antes del cierre
        mf = { tipo: 'suelto', texto: ensureDot(item) };
      }

      mapped.push(mf);
    }

    // 3) Integración con base:
    //    - patológico reemplaza su frase normal
    //    - adicional se añade detrás de su frase normal
    //    - suelto va antes del cierre
    let working = [...baseLines];

    const addQueueByNormal = new Map<string, string[]>();
    const replaceByNormal = new Map<string, string>();
    const looseFindings: string[] = [];

    for (const mf of mapped) {
      if (mf.tipo === 'adicional' && mf.fraseNormal) {
        const list = addQueueByNormal.get(mf.fraseNormal) || [];
        list.push(mf.texto);
        addQueueByNormal.set(mf.fraseNormal, list);
      } else if (mf.tipo === 'patologico' && mf.fraseNormal) {
        replaceByNormal.set(mf.fraseNormal, mf.texto);
      } else if (mf.tipo === 'suelto') {
        looseFindings.push(mf.texto);
      }
    }

    // 3.a) reemplazos patológicos
    working = working
      .map((line) => {
        const rep = replaceByNormal.get(line);
        return rep ? rep : line;
      })
      .filter(Boolean);

    // 3.b) añadidos tras su normal (o tras la patológica si sustituyó)
    working = working.flatMap((line) => {
      const rep = replaceByNormal.get(line);
      if (rep) {
        const adds = addQueueByNormal.get(line) || [];
        return [rep, ...adds];
      } else {
        const adds = addQueueByNormal.get(line) || [];
        return adds.length ? [line, ...adds] : [line];
      }
    });

    // 3.c) sueltos antes del cierre
    working = ensureClosing(working);
    if (looseFindings.length) {
      const closing = (DEFAULT_CLOSING_TEXT || 'Sin otros hallazgos.').trim();
      const idx = working.findIndex((l) => normalize(l) === normalize(closing));
      if (idx === -1) working.push(...looseFindings);
      else working.splice(idx, 0, ...looseFindings);
    }

    // 4) Postproceso propio (normas que ya tenías)
    working = applyPostprocessNorms(working, {
      templateMode: templateMode,
    });

    // 5) FORMATEO FINAL EXACTO DE BLOQUES / SALTOS
    const hallazgosText = formatHallazgos(working, { closingText: DEFAULT_CLOSING_TEXT });

    const finalText =
      `${title}\n\n` + // doble salto tras TÍTULO
      `${technique}\n\n` + // doble salto tras TECNICA (tu técnica ya es "TECNICA:\nSe realiza...")
      `${buildHallazgosHeader()}\n` + // "HALLAZGOS:" + salto simple
      `${hallazgosText}`; // dentro del bloque, el formateador controla los dobles/simples

    setReport(finalText);
  }

  return (
    <div
      className="app"
      style={{
        maxWidth: 980,
        margin: '40px auto',
        padding: '0 16px',
        fontFamily:
          'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
      }}
    >
      <h1 style={{ fontSize: 24, marginBottom: 8 }}>Generador de informes TC</h1>
      <p style={{ marginTop: 0, color: '#666' }}>
        1) Pega las <strong>etiquetas</strong> (p. ej.{' '}
        <code>[TC-TORAX] [CON CONTRASTE]</code>) · 2) Pega los{' '}
        <strong>hallazgos</strong> (frases separadas por punto).
      </p>

      <div
        style={{
          display: 'grid',
          gap: 16,
          gridTemplateColumns: '1fr 1fr',
          alignItems: 'start',
        }}
      >
        <div>
          <label style={{ fontWeight: 600 }}>Etiquetas (primer mensaje)</label>
          <textarea
            placeholder="[TC-TORAX] [CON CONTRASTE]"
            value={labelsRaw}
            onChange={(e) => setLabelsRaw(e.target.value)}
            rows={4}
            style={{ width: '100%', marginTop: 6 }}
          />
          <div style={{ marginTop: 12, fontSize: 12, color: '#666' }}>
            <div>
              <strong>Regiones:</strong> {regions.join(', ') || '—'}
            </div>
            <div>
              <strong>Contraste:</strong> {contrast || '—'}
            </div>
          </div>
        </div>

        <div>
          <label style={{ fontWeight: 600 }}>Hallazgos (segundo mensaje)</label>
          <textarea
            placeholder="Derrame pleural izquierdo. Quistes hepáticos. Valida frases normales."
            value={findingsRaw}
            onChange={(e) => setFindingsRaw(e.target.value)}
            rows={8}
            style={{ width: '100%', marginTop: 6 }}
          />
          <button
            onClick={handleGenerate}
            style={{
              marginTop: 12,
              padding: '10px 16px',
              border: '1px solid #ccc',
              borderRadius: 8,
              cursor: 'pointer',
              background: '#111',
              color: '#fff',
              fontWeight: 600,
            }}
          >
            Generar informe
          </button>
        </div>
      </div>

      <div style={{ marginTop: 24 }}>
        <label style={{ fontWeight: 600 }}>Informe final</label>
        <textarea readOnly value={report} rows={18} style={{ width: '100%', marginTop: 6 }} />
      </div>

      <div style={{ marginTop: 12, fontSize: 12, color: '#888' }}>
        <div>Presets cargados: {Array.isArray(presets) ? presets.length : 0}</div>
        <div>Frases normales: {Array.isArray(normalPhrases) ? normalPhrases.length : 0}</div>
        <div>Bloques de hallazgos: {Array.isArray(findingsJson) ? findingsJson.length : 0}</div>
        <div>Entrada fuzzy: {Array.isArray(fuzzyLexicon) ? fuzzyLexicon.length : 0}</div>
      </div>
    </div>
  );
}


Si ya tienes la versión de una sola caja de texto (donde parseas el tipo de TC de la primera frase), no pasa nada: lo único imprescindible es que al final, en vez de working.join(' '), llames a formatHallazgos(working, ...) como arriba.