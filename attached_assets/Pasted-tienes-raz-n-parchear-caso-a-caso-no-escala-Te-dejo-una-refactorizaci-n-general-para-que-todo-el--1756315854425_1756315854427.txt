tienes razón: parchear caso a caso no escala. Te dejo una refactorización general para que todo el “mapeo → sustitución/añadido → formato final” lo decida OpenAI Responses con tus tablas locales como contexto reducido. La app queda así:

La UI tiene un solo textarea (dictado) + botón.

La app deduce etiquetas (tórax/abdomen + (con|sin) contraste) de la 1ª frase.

Construye plantilla base desde normalPhrases.json.

Llama a un micro-backend (server/index.ts) que usa Responses con JSON Schema (respuesta 100% parseable).

El modelo devuelve un plan estructurado: qué reemplazar, qué añadir y qué dejar suelto.

El front aplica el plan y formatea con tus saltos de línea:
doble salto solo entre pleura → hígado (y, como siempre, bajo TÍTULO/TECNICA/HALLAZGOS), el resto salto simple.

Incluyo todos los archivos completos que hay que tocar o crear. Copia/pega tal cual.

1) package.json (completo)
{
  "name": "radiology-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "main": "electron/main.js",
  "scripts": {
    "dev": "concurrently -k \"npm:dev:vite\" \"npm:dev:server\"",
    "dev:vite": "vite",
    "dev:server": "ts-node server/index.ts",
    "build:web": "tsc -b && vite build",
    "build": "npm run build:web",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "openai": "^4.61.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "express": "^4.19.2",
    "cors": "^2.8.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.30",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^5.0.0",
    "concurrently": "^8.2.2",
    "eslint": "^9.33.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "ts-node": "^10.9.2",
    "typescript": "~5.8.3",
    "vite": "^7.1.2"
  }
}


Importante: guarda tu clave como secreto del repl (o variable local) OPENAI_API_KEY. No la pongas en el front.

2) vite.config.ts (completo)
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    strictPort: true,
    allowedHosts: true,
    proxy: {
      '/api': {
        target: 'http://localhost:8787',
        changeOrigin: true
      }
    }
  },
  preview: {
    port: 5173,
    allowedHosts: true
  }
});

3) Nuevo server/index.ts (micro-backend Responses)
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import OpenAI from 'openai';

const app = express();
app.use(cors());
app.use(express.json({ limit: '2mb' }));

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// JSON Schema para forzar respuesta estructurada
const planSchema = {
  name: 'llm_plan',
  schema: {
    type: 'object',
    additionalProperties: false,
    properties: {
      replaces: {
        type: 'array',
        items: {
          type: 'object',
          additionalProperties: false,
          properties: {
            fraseNormal: { type: 'string' },
            texto: { type: 'string' }
          },
          required: ['fraseNormal', 'texto']
        }
      },
      adds: {
        type: 'array',
        items: {
          type: 'object',
          additionalProperties: false,
          properties: {
            fraseNormal: { type: 'string' },
            textos: {
              type: 'array',
              items: { type: 'string' }
            }
          },
          required: ['fraseNormal', 'textos']
        }
      },
      loose: {
        type: 'array',
        items: { type: 'string' }
      },
      notes: {
        // opcional para trazabilidad (debug)
        type: 'array',
        items: { type: 'string' }
      }
    },
    required: ['replaces', 'adds', 'loose']
  },
  strict: true
} as const;

app.post('/api/llm-plan', async (req, res) => {
  try {
    const {
      dictadoItems,          // string[]
      baseNormals,           // string[]
      maps,                  // { pathologicalMap: Record<string,string>, additionalMap: Record<string,string>, fuzzyMap: Record<string,string> }
      templateMode           // boolean
    } = req.body || {};

    if (!Array.isArray(dictadoItems) || !Array.isArray(baseNormals) || !maps) {
      return res.status(400).json({ error: 'Payload inválido.' });
    }

    // Prompt compacto: reglas + datos reducidos
    const system = [
      `Eres un asistente clínico que integra hallazgos en una plantilla de informe.`,
      `Entrada:`,
      `- "baseNormals": lista EXACTA de frases normales disponibles para este estudio (texto literal).`,
      `- "maps.pathologicalMap": mapa {hallazgo_oficial -> frase_normal_que_debe_REEMPLAZAR}.`,
      `- "maps.additionalMap": mapa {hallazgo_oficial -> frase_normal_que_debe_MANTENERSE_y_AÑADIR_DETRAS}.`,
      `- "maps.fuzzyMap": sinonimos_y_erratas -> hallazgo_oficial.`,
      `- "dictadoItems": frases dictadas por el médico (positivas). Ignora "Sin otros hallazgos" y "Valida frases normales".`,
      `Tu tarea:`,
      `1) Para cada item de dictado, si coincide con un hallazgo_oficial (directo o via fuzzyMap) y existe en pathologicalMap -> produce un REEMPLAZO sobre su frase normal.`,
      `2) Si coincide y existe en additionalMap -> produce un AÑADIDO detrás de su frase normal.`,
      `3) Si no puedes mapear a ninguna frase normal (no existe correspondencia), colócalo en "loose".`,
      `4) Nunca inventes frases normales nuevas. Usa SOLO las de baseNormals.`,
      `5) Respeta el texto del usuario, asegurando punto final.`,
      `6) Si "templateMode" es true, aplica el comportamiento normal (no cambia salida JSON; el client hará el orden y formato).`,
      `Salida: objeto JSON con {replaces, adds, loose}.`
    ].join('\n');

    const userPayload = {
      baseNormals,
      dictadoItems,
      maps,
      templateMode
    };

    const response = await openai.responses.create({
      model: 'gpt-4o-mini', // rápido y barato; puedes subir a gpt-4.1 si quieres
      response_format: { type: 'json_schema', json_schema: planSchema },
      input: [
        { role: 'system', content: system },
        { role: 'user', content: JSON.stringify(userPayload) }
      ]
    });

    const content = response.output_text ?? '';
    // responses con json_schema ya devuelve texto JSON válido
    const plan = JSON.parse(content);
    return res.json(plan);
  } catch (err: any) {
    console.error('LLM error:', err?.message || err);
    return res.status(500).json({ error: 'LLM failure' });
  }
});

const PORT = process.env.PORT || 8787;
app.listen(PORT, () => {
  console.log(`LLM server listening on http://localhost:${PORT}`);
});


Replit/GitHub Secrets: define OPENAI_API_KEY en el panel de secretos (o .env local).

4) src/App.tsx (completo)
// src/App.tsx
import { useMemo, useState } from 'react';

// Datos
import normalPhrases from './data/normalPhrases.json';
import findingsJson from './data/findings.json';
import fuzzyLexicon from './data/fuzzyLexicon.json';
import presets from './data/presets.json';

// Plantillas (título / técnica / helpers etiquetas)
import {
  buildReportTitle,
  buildTechniqueBlock,
  buildHallazgosHeader,
  type RegionTag,
  type ContrastTag,
} from './prompts/templates';

// Cierre por defecto
import { DEFAULT_CLOSING_TEXT } from './config/constants';

// =========================
// Tipos locales
// =========================
type NormalPhrase = {
  text: string;
  regions: string[];
  contrast: string[]; // 'SIEMPRE' | 'CON CONTRASTE' | 'SIN CONTRASTE'
};

type FindingEntry = {
  zona_anatomica: string;
  frase_normal: string; // puede ser "Null." en zona Otros
  hallazgos_patologicos: string[];
  hallazgos_adicionales: string[];
};

type FuzzyEntry = {
  frase_normal: string;
  hallazgo_oficial: string;
  sinonimos?: string[];
  errores_comunes?: string[];
  excluir?: string[];
};

type LlmPlan = {
  replaces: Array<{ fraseNormal: string; texto: string }>;
  adds: Array<{ fraseNormal: string; textos: string[] }>;
  loose: string[];
  notes?: string[];
};

// =========================
// Helpers texto
// =========================
const SENTENCE_SPLIT = /[.]+|\n+/g;

function normalize(s: string) {
  return s
    .toLowerCase()
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .replace(/[^\p{L}\p{N}\s]/gu, '')
    .replace(/\s+/g, ' ')
    .trim();
}

function ensureDot(s: string) {
  const t = s.trim();
  if (!t) return t;
  return /[.:]$/.test(t) ? t : `${t}.`;
}

// =========================
// Mapeos reducidos para LLM
// =========================
function buildMapsForLLM(findingTable: FindingEntry[], fuzzy: FuzzyEntry[]) {
  const pathologicalMap: Record<string, string> = {};
  const additionalMap: Record<string, string> = {};
  const fuzzyMap: Record<string, string> = {};

  for (const row of findingTable) {
    const fn = row.frase_normal?.trim();
    if (!fn) continue;
    for (const hp of row.hallazgos_patologicos || []) {
      const key = hp.trim();
      if (key) pathologicalMap[key] = fn;
    }
    for (const ha of row.hallazgos_adicionales || []) {
      const key = ha.trim();
      if (key) additionalMap[key] = fn;
    }
  }
  for (const e of fuzzy) {
    const target = e.hallazgo_oficial?.trim();
    if (!target) continue;
    const add = (v: string) => {
      const k = v.trim();
      if (!k) return;
      // mapeamos sinónimos/erratas al oficial
      fuzzyMap[k] = target;
    };
    add(target);
    for (const s of e.sinonimos || []) add(s);
    for (const err of e.errores_comunes || []) add(err);
  }

  return { pathologicalMap, additionalMap, fuzzyMap };
}

// =========================
// Deducción de etiquetas desde 1ª frase
// =========================
function autoInferTagsFromFirstSentence(first: string): { regions: RegionTag[]; contrast: ContrastTag | null } {
  const n = normalize(first);
  const regions: RegionTag[] = [];
  if (/\btc\b.*torax|t[oó]rax/.test(n)) regions.push('TC-TORAX' as RegionTag);
  if (/\btc\b.*abdomen|abdomen/.test(n)) regions.push('TC-ABDOMEN' as RegionTag);
  if (!regions.length) {
    // fallback por si dice "TC de tórax y abdomen..."
    if (/torax|t[oó]rax/.test(n)) regions.push('TC-TORAX' as RegionTag);
    if (/abdomen/.test(n)) regions.push('TC-ABDOMEN' as RegionTag);
  }

  let contrast: ContrastTag | null = null;
  if (/con\s+contraste|contraste\s*ev/.test(n)) contrast = 'CON CONTRASTE' as ContrastTag;
  else if (/sin\s+contraste|simple/.test(n)) contrast = 'SIN CONTRASTE' as ContrastTag;

  return { regions, contrast };
}

// =========================
// Filtrado plantilla base
// =========================
function contrastMatches(needed: string[], studyContrast: ContrastTag | null) {
  if (needed.includes('SIEMPRE')) return true;
  if (!studyContrast) return false;
  return needed.includes(studyContrast);
}

function regionsMatch(needed: string[], studyRegions: RegionTag[]) {
  const set = new Set(studyRegions);
  return needed.some(r => set.has(r as RegionTag));
}

function buildBaseTemplate(
  allNormals: NormalPhrase[],
  regions: RegionTag[],
  contrast: ContrastTag | null
) {
  const lines: string[] = [];
  for (const row of allNormals) {
    const okRegion = regionsMatch(row.regions, regions);
    const okContrast = contrastMatches(row.contrast, contrast);
    if (okRegion && okContrast) lines.push(row.text.trim());
  }
  return lines;
}

// =========================
// Agrupación/secciones + formato líneas
// =========================

// Mapea frases normales exactas → clave de sección
const SECTION_BY_NORMAL: Record<string, string> = {
  // TÓRAX
  'Estructuras mediastínicas sin alteraciones significativas.': 'thorax.mediastino',
  'Arteria pulmonar de calibre normal.': 'thorax.mediastino',
  'No se observan signos de TEP central.': 'thorax.mediastino',
  'No se observan adenopatías mediastínicas o hiliares aumentadas de tamaño.': 'thorax.adenos.mediastino_hilio',
  'No se observan adenopatías supraclaviculares o axilares aumentadas de tamaño.': 'thorax.adenos.axil_supraclav',
  'Parénquima pulmonar sin alteraciones a destacar. No se observan condensaciones de espacio aéreo ni nódulos pulmonares.': 'thorax.parenquima',
  'Espacios pleurales libres.': 'thorax.pleura',

  // ABDOMEN
  'Hígado de tamaño y morfología normal y contornos lisos.': 'abd.higado',
  'No se observan lesiones focales hepáticas.': 'abd.higado',
  'Vena porta y ramas portales intrahepáticas permeables. Venas suprahepáticas y eje esplenoportal permeable.': 'abd.vasos_hepaticos',
  'No se observa dilatación de la vía biliar intra o extrahepática.': 'abd.via_biliar',
  'Vesícula biliar sin evidencia de litiasis en su interior, engrosamientos murales o signos inflamatorios agudos.': 'abd.vesicula',
  'Bazo de tamaño y morfología normal. No se observan lesiones focales.': 'abd.bazo_pancreas_adrenales',
  'Páncreas de tamaño y morfología normales. No se observa dilatación del conducto de Wirsung.': 'abd.bazo_pancreas_adrenales',
  'Glándulas suprarrenales de tamaño y morfología normales.': 'abd.bazo_pancreas_adrenales',
  'Riñón derecho de tamaño y morfología normales.': 'abd.renales',
  'No se observan lesiones focales ni dilatación de la vía urinaria derecha.': 'abd.renales',
  'Riñón izquierdo de tamaño y morfología normales.': 'abd.renales',
  'No se observan lesiones focales ni dilatación de la vía urinaria izquierda.': 'abd.renales',
  'No se observan adenopatías intraabdominales aumentadas de tamaño.': 'abd.adenos',
  'No se observan adenopatías pélvicas o inguinales aumentadas de tamaño.': 'abd.adenos',
  'No se observan colecciones, neumoperitoneo ni líquido libre intraabdominal.': 'abd.peritoneo'
};

// Orden de secciones
const SECTION_ORDER = [
  'thorax.mediastino',
  'thorax.adenos.mediastino_hilio',
  'thorax.adenos.axil_supraclav',
  'thorax.parenquima',
  'thorax.pleura',

  // ← Doble salto justo al pasar a hígado
  'abd.higado',
  'abd.vasos_hepaticos',
  'abd.via_biliar',
  'abd.vesicula',
  'abd.bazo_pancreas_adrenales',
  'abd.renales',
  'abd.adenos',
  'abd.peritoneo'
] as const;

function formatHallazgosWithSections(lines: string[]) {
  // Bucket lines por sección (desconocidas al final, antes del cierre)
  const buckets = new Map<string, string[]>();
  for (const key of SECTION_ORDER) buckets.set(key, []);
  const unknown: string[] = [];

  const closing = (DEFAULT_CLOSING_TEXT || 'Sin otros hallazgos.').trim();
  for (const raw of lines) {
    const line = raw.trim();
    if (!line) continue;
    if (normalize(line) === normalize(closing)) continue; // añadimos al final
    const sec = SECTION_BY_NORMAL[line];
    if (sec && buckets.has(sec)) buckets.get(sec)!.push(line);
    else unknown.push(line);
  }

  // Reconstrucción con saltos:
  // - salto simple entre secciones en general
  // - doble salto SOLO entre 'thorax.pleura' → 'abd.higado'
  const parts: string[] = [];

  for (let i = 0; i < SECTION_ORDER.length; i++) {
    const sec = SECTION_ORDER[i];
    const arr = buckets.get(sec)!;
    if (!arr.length) continue;
    parts.push(arr.join(' '));

    const next = SECTION_ORDER[i + 1];
    if (sec === 'thorax.pleura' && next === 'abd.higado') {
      parts.push(''); // línea en blanco extra (doble salto)
    }
  }

  // Luego desconocidas (sueltos clasificados/añadidos que no referencian normal)
  if (unknown.length) parts.push(unknown.join(' '));

  // Cierre final
  parts.push(closing);

  // Unir con salto de línea. Los '' en parts introducen saltos extra.
  return parts.filter(p => p !== undefined).join('\n');
}

// =========================
// Front-end
// =========================
export default function App() {
  const [dictado, setDictado] = useState<string>('');
  const [report, setReport] = useState<string>('');
  const [busy, setBusy] = useState<boolean>(false);

  // 1ª frase → etiquetas
  const firstSentence = useMemo(() => {
    const m = dictado.split(SENTENCE_SPLIT).map(s => s.trim()).filter(Boolean);
    return m[0] || '';
  }, [dictado]);

  const { regions, contrast } = useMemo(
    () => autoInferTagsFromFirstSentence(firstSentence),
    [firstSentence]
  );

  const title = useMemo(() => buildReportTitle(regions, contrast), [regions, contrast]);
  const technique = useMemo(() => buildTechniqueBlock(regions, contrast), [regions, contrast]);

  // plantilla base por etiquetas
  const baseNormals = useMemo(
    () => buildBaseTemplate(normalPhrases as NormalPhrase[], regions, contrast),
    [regions, contrast]
  );

  async function handleGenerate() {
    try {
      setBusy(true);
      // separar items (ignorar primera frase de tipo TC)
      const items = (dictado.match(SENTENCE_SPLIT) ? dictado.split(SENTENCE_SPLIT) : [dictado])
        .map(x => x.trim())
        .filter(Boolean);

      const onlyFindings = items.slice(1); // desde el 2º en adelante
      const templateMode = onlyFindings.some(x => normalize(x).includes('valida frases normales'));
      const filtered = onlyFindings.filter(x => {
        const n = normalize(x);
        return n !== normalize('sin otros hallazgos') && !n.includes('valida frases normales');
      });

      const maps = buildMapsForLLM(findingsJson as FindingEntry[], fuzzyLexicon as FuzzyEntry[]);

      // Llamada al backend LLM
      const plan: LlmPlan = await fetch('/api/llm-plan', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          dictadoItems: filtered,
          baseNormals,
          maps,
          templateMode
        })
      }).then(r => r.json());

      // Aplicar plan sobre baseNormals
      let working = [...baseNormals];

      // REEMPLAZOS
      const repMap = new Map<string, string>();
      for (const r of plan.replaces || []) {
        repMap.set(r.fraseNormal, ensureDot(r.texto));
      }
      working = working.map(line => repMap.get(line) || line);

      // AÑADIDOS
      const addMap = new Map<string, string[]>();
      for (const a of plan.adds || []) {
        const list = addMap.get(a.fraseNormal) || [];
        list.push(...a.textos.map(ensureDot));
        addMap.set(a.fraseNormal, list);
      }
      working = working.flatMap(line => {
        const adds = addMap.get(line) || [];
        if (adds.length) return [line, ...adds];
        return [line];
      });

      // SUELTOS
      const loose = (plan.loose || []).map(ensureDot);
      const closing = (DEFAULT_CLOSING_TEXT || 'Sin otros hallazgos.').trim();
      const hasClosing = working.some(l => normalize(l) === normalize(closing));
      if (!hasClosing) working.push(closing);
      if (loose.length) {
        const idx = working.findIndex(l => normalize(l) === normalize(closing));
        if (idx === -1) working.push(...loose);
        else working.splice(idx, 0, ...loose);
      }

      // Formateo final con secciones y saltos pedidos
      const hallazgos = formatHallazgosWithSections(working);

      const finalText =
        `${title}\n\n` +
        `${technique}\n\n` +
        `${buildHallazgosHeader()}\n` +
        `${hallazgos}`;

      setReport(finalText);
    } catch (e) {
      console.error(e);
      setReport('Error generando el informe.');
    } finally {
      setBusy(false);
    }
  }

  return (
    <div
      className="app"
      style={{
        maxWidth: 760,
        margin: '40px auto',
        padding: '0 16px',
        fontFamily:
          'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'
      }}
    >
      <h1 style={{ fontSize: 22, marginBottom: 8 }}>Generador de informes TC</h1>
      <p style={{ marginTop: 0, color: '#666' }}>
        Pega el dictado completo (la 1ª frase debe ser el tipo de TC). Ej.: <code>TC de tórax con contraste. … Valida frases normales.</code>
      </p>

      <label style={{ fontWeight: 600 }}>Dictado</label>
      <textarea
        placeholder="TC de tórax con contraste. Nódulo... Valida frases normales."
        value={dictado}
        onChange={(e) => setDictado(e.target.value)}
        rows={8}
        style={{ width: '100%', marginTop: 6 }}
      />

      <button
        onClick={handleGenerate}
        disabled={busy}
        style={{
          marginTop: 12,
          padding: '10px 16px',
          border: '1px solid #ccc',
          borderRadius: 8,
          cursor: 'pointer',
          background: busy ? '#666' : '#111',
          color: '#fff',
          fontWeight: 600
        }}
      >
        {busy ? 'Generando…' : 'Generar informe'}
      </button>

      <div style={{ marginTop: 18, fontSize: 12, color: '#666' }}>
        <div><strong>Regiones detectadas:</strong> {regions.join(', ') || '—'}</div>
        <div><strong>Contraste:</strong> {contrast || '—'}</div>
        <div><strong>Frases base incluidas:</strong> {baseNormals.length}</div>
      </div>

      <div style={{ marginTop: 24 }}>
        <label style={{ fontWeight: 600 }}>Informe final</label>
        <textarea
          readOnly
          value={report}
          rows={18}
          style={{ width: '100%', marginTop: 6 }}
        />
      </div>

      <div style={{ marginTop: 12, fontSize: 12, color: '#888' }}>
        <div>Presets: {Array.isArray(presets) ? presets.length : 0}</div>
        <div>Frases normales: {Array.isArray(normalPhrases) ? normalPhrases.length : 0}</div>
        <div>Bloques de hallazgos: {Array.isArray(findingsJson) ? findingsJson.length : 0}</div>
        <div>Entrada fuzzy: {Array.isArray(fuzzyLexicon) ? fuzzyLexicon.length : 0}</div>
      </div>
    </div>
  );
}

Cómo usarlo

Instala deps:

npm i


Crea el secreto OPENAI_API_KEY (en Replit “Secrets” o .env local).

Arranca en dev:

npm run dev


Abre el preview de Vite.

El server LLM levanta en http://localhost:8787 y está proxificado por /api.

Por qué esto soluciona “todo” de forma general

Ya no metemos regex frágiles en front: el LLM hace el mapeo a patológico/adicional/suelto usando tus tablas (findings.json + fuzzyLexicon.json) reducidas a tres mapas compactos.

El formato de salida está forzado por schema → siempre obtienes {replaces, adds, loose}.

El front aplica el plan de forma determinista sobre la plantilla base filtrada por etiquetas.

El formateador impone tus saltos de línea: doble solo entre pleura → hígado; el resto salto simple; cierre único.

Si algo no existe en tus tablas, no se inventa ninguna frase normal → se va a loose (antes del cierre), tal y como pediste.